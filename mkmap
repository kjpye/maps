#!/usr/bin/env raku

use v6;

use DB::Pg;
use Geo::Coordinates::UTM;
use NativeCall; # only for floating point reading routines

### Global symbol definitions

my $TMP; # file handle for temporary output

my $debug = 0;
my %defaults;
my $copyright = '';

my $symbols = 'Symbols_GA'; # Which symbols set to use

my $scale = 25000; # map scale; defaults to 1:25000

# positions of map corners

my ($lllongitude, $lllatitude);
my ($lrlongitude, $lrlatitude);
my ($ullongitude, $ullatitude);
my ($urlongitude, $urlatitude);
my ($lleasting, $llnorthing);
my ($lreasting, $lrnorthing);
my ($uleasting, $ulnorthing);
my ($ureasting, $urnorthing);
my Str $zone;

my @properties;
my %dependencies;
my $roadnames;

my @displays; # temporary storage for [no]display options
my %allobjects;
my %drawobjects;

my $contourinterval = 1;

my %papersizes;
my $papersize = 'a3';
my ($paperwidth, $paperheight);
my $orientation = 'landscape';

my @annotations;

my %messages;
sub one-message($msg) {
    note $msg unless %messages{$msg}.defined;
    %messages{$msg} = 1;
}

sub set-papersizes() {
  # Keys are papersize, values are a string with
  # width and length in mm separated by commas.
  %papersizes = (
    'a'      => '216,   279',
    'b'      => '279,   432',
    'c'      => '432,   559',
    'd'      => '559,   864',
    'e'      => '864,   1118',
    'letter' => '215.9, 279.4',
  );

# Calculate metric A and B paper sizes
  my $sqsq2 = sqrt(sqrt(2));
  my $l = 1000 * $sqsq2;
  my $w = 1e6/$l;
# $l * $w should be 1 square metre (1e6 mm^2) with a ratio of sqrt(2)
  for ^10 -> $s {
    %papersizes{'a' ~ $s.Str} = "$w, $l";
    %papersizes{'b' ~ $s.Str} = "{$w*$sqsq2}, {$l*$sqsq2}";
    $l = $w;
    $w = $l / sqrt(2);
  }
}

my ($xoffset, $yoffset, $xmin, $ymin); # where the map actually goes on the page

sub add-annotation(Real $long, Real $lat, Real $xoffset, Real $yoffset, Str $string) {
    my $annotation = {};
    %($annotation)<long>    = $long;
    %($annotation)<lat>     = $lat;
    %($annotation)<xoffset> = $xoffset;
    %($annotation)<yoffset> = $yoffset;
    %($annotation)<string>  = $string;
    @annotations.push: $annotation;
}

my ($leftmarginwidth, $lowermarginwidth, $rightmarginwidth, $uppermarginwidth)
    = (30, 35, 30, 25); # negative to bleed over page boundary
my ($gridwidth, $graticulewidth);
my ($gridheight, $graticuleheight);
my $db = 'vicmap'; # which database to access
my $grid-spacing = 1000; # spacing betwen grid lines in metres
my $graticule-spacing = 1.0/60; # spacing between graticule lines in degrees
my (Bool $ongrid, Bool $ongraticule) = (False, False);
my (Bool $bleedright, Bool $bleedleft, Bool $bleedtop, Bool $bleedbottom) = (False, False, False, False);
my %emphasise-roads;
my $outputfile;
my $title = '';

sub process-option-file($file, $error) {
  if $file.IO.e and $file.IO.f and $file.IO.r {
note "process-option-file: $file ($error)";
    for $file.IO.lines -> $line is copy;{
      $line ~~ s/'#' .*//;
      $line ~~ s/^\s+//;
      $line ~~ s/\s+$//;
      next unless $line;
      process-option($line);
    }
  } else {
    fail "Could not open $file" if $error;
  }
}

sub process-option($arg is copy) {
    note "Processing option $arg" if $debug >= 1;
    if $arg.IO.r {
        note "Processing include file $arg" if $debug >= 1;
        process-option-file $arg, 1;
        return;
    }
    if $arg ~~ m:i/ ^ annotation <.ws> \= <.ws>
                                ( \-? <[\d .]>+ )
                 <[, \s]> <.ws> ( \-? <[\d .]>+ )
                 <[, \s]> <.ws> ( \-? <[\d .]>+ )
                 <[, \s]> <.ws> ( \-? <[\d .]>+ )
                 <[, \s]> <.ws> (.*)
               / {
	add-annotation(+$0, +$1, +$2, +$3, ~$4);
	return;
    }
    if $arg ~~ m:i/ ^ emph '=' (.*)/ {
        %emphasise-roads{$0} = 1;
        return;
    }
    if $arg ~~ m:i/^title <.ws> '=' <.ws> (.*)/ {
      $title = $0;
      return;
    }
    if $arg ~~ m:i/^roadname[s]? <.ws> '=' <.ws> (.*)/ {
      $roadnames = $0.IO.open: :w;
    }
# ignore whitespace in all remaining options
    $arg ~~ s:g/\s+//;
    given $arg {
    when m:i/^draw '=' (\d+)$/ {
        draw-map if $0;
    }
    when m:i/^exit '=' (\d+)$/ {
        exit $0;
    }
    when m:i/ ^ debug '=' (\d+) $/ {
        $debug = $0;
    }
    when m:i/ ^ pa[per|ge]size '=' (.*) / {
	$papersize = $0;
    }
    when m:i/ orientation '=' (.*) / {
	$orientation = $0;
    }
    when m:i/ bleedright '=' (.*) / {
	$bleedright = ?+$0;
    }
    when m:i/ bleedleft '=' (.*)/ {
	$bleedleft = ?+$0;
    }
    when m:i/ bleedtop '=' (.*) / {
	$bleedtop = ?+$0;
    }
    when m:i/ bleedbottom '=' (.*)/ {
	$bleedbottom = ?+$0;
    }
    when m:i/^leftmargin[width]? '=' (\d+[\.\d+]?)$/ {
        $leftmarginwidth = $0;
    }
    when m:i/^rightmargin[width]? '=' (\d+[\.\d+]?)$/ {
        $rightmarginwidth = $0;
    }
    when m:i/^[lower|bottom]margin[width]? '=' (\d+[\.\d+]?)$/ {
        $lowermarginwidth = $0;
    }
    when m:i/^[upper|top]margin[width]? '=' (\d+[\.\d+]?)$/ {
        $uppermarginwidth = $0;
    }
    when m:i/d[ata]?b[ase]? '=' (.*)/ {
	$db = $0;
    }
    when m:i/^ lat[itude]? '=' ( \-? <[\d\.]>+ ) $ / {
	$lllatitude = +$0;
	$ongraticule = True;
    }
    when m:i/^ long[itude]? '=' ( \-? <[\d\.]>+ ) $ / {
	$lllongitude = +$0;
	$ongraticule = True;
    }
    when m:i/^east[ing]? '=' (\d+)(k?)m?$/ {
	$lleasting = $0;
	$lleasting *= 1000 if $1.lc eq 'k';
	$ongrid = True;
    }
    when m:i/^north[ing]? '=' (\d+)(k?)m?$/ {
        $llnorthing = $0;
	$llnorthing *= 1000 if $1.lc eq 'k';
	$ongrid = True;
    }
    when m:i/^width '=' (\d+[\.\d+]?)([kK])?([dDmM]?)$/ {
	if ($2.lc eq 'm') {
	    $gridwidth = $0;
            $gridwidth *= 1000 if $1.lc eq 'k';
	    $ongrid = True;
	} else {
	    $graticulewidth = $0;
	    $ongraticule = True;
	}
    }
    when m:i/^height '=' (\d+[\.\d+]?)([kK])?([dDmM]?)$/ {
	if ($2.lc eq 'm') {
	    $gridheight = $0;
            $gridheight *= 1000 if $1.lc eq 'k';
	    $ongrid = True;
	} else {
	    $graticuleheight = $0;
	    $ongraticule = True;
	}
    }
    when m:i/^zone? '=' (\d+<[ A .. Z ]>?)$/ {
        $zone = $0.uc;
	note "Zone: $zone\n";
    }
    when m:i/^scale\=[1\:]?(\d+)(<[kKmM]>?)$/ {
	$scale = $0;
	$scale *= 1000    if $1.lc eq 'k';
	$scale *= 1000000 if $1.lc eq 'm';
        note "scale set to $scale" if $debug > 1;
    }
    when m:i/ ^ grid[spacing]? \= (\d+) (k?) m?$/ {
	$grid-spacing = $0;
	$grid-spacing *= 1000 if $1.defined && $1.lc eq 'k';
    }
    when m:i/^ graticule[spacing]? \= ([\d*\.]?\d+) (<[dDmM]>?) $/ {
	$graticule-spacing = $0;
	$graticule-spacing /= 60 unless $1.lc eq 'd';
    }
    when m:i/^[no]?display[all]? '=' (\S+)$/ {
        @displays.push: $arg;
    }
    when m:i/^symbols '=' (\S+)$/ {
	$symbols = $0.lc;
    }
    when m:i/^property \= (<[\d,]>+) / {
       @properties.push: $0.split(',');
    }
    when m:i/^contour[interval]? \= (\d+)/ {
      $contourinterval = $0;
      note "Setting contour interval to $contourinterval" if $debug > 1;
    }
    when m:i/^file '=' (.*)/ {
        my $includefile = $0;
        note "Processing include file $includefile" if $debug >= 1;
        process-option-file $includefile, 1;
    }
    when m:i/^output[file]? '=' (.*)/ {
      $outputfile = $0;
      $outputfile = Nil if $outputfile eq 'none';
    }
    default { note "Unknown option \"$arg\" ignored\n"; }
  }
}

sub postscript-encode-font(Str $font) {
  print qq:to 'EOF';
    /{$font} findfont
    dup length dict begin
    \{ 1 index /FID ne \{def} \{pop pop} ifelse } forall
    /Encoding ISOLatin1Encoding def
    currentdict
    end
    /{$font}-Latin1 exch definefont pop
    EOF
}

sub postscript-prefix() {
  print qq :to 'EOF';
\%!PS-Adobe
\%! $copyright
$papersize
72 25.4 div dup scale
EOF

  say "$paperheight 0 translate 90 rotate" if $orientation eq 'landscape';

  postscript-encode-font('Helvetica');
  postscript-encode-font('Helvetica-Narrow');
  postscript-encode-font('Helvetica-Narrow-Oblique');
  postscript-encode-font('Helvetica-Narrow-BoldOblique');
  postscript-encode-font('Helvetica-BoldOblique');

  if (!$bleedbottom and $lowermarginwidth > 20) {
    print qq :to 'EOF'
      /Helvetica-Narrow-Latin1 3 selectfont
      8 8 moveto
      ($copyright) show
      $paperwidth 8 sub 8 moveto (1:$scale) dup stringwidth pop neg 0 rmoveto show
      /Helvetica-Narrow-Latin1 8 selectfont
      $paperwidth 2 div 8 moveto ($title) dup stringwidth pop neg 2 div 0 rmoveto show
    EOF
  }
}

sub read-points (Str $shape) {
  if $shape ~~ /^POLYGON\(\(/ {
    $shape.comb(/ <[+-]>? \d+ [ '.' \d+ ]/ );
  } else {
    note "Unknown shape in $shape";
  }
}

my $point-count = 0;
my $object-count = 0;
my $xscale;
my $yscale;
    
sub grid2page(Real $xin, Real $yin) {
  ( ($xin + $xoffset) * $xscale + $xmin,
           ($yin + $yoffset) * $yscale + $ymin);
}

sub latlon2page($xin, $yin) {
    ++$point-count;
    my ($tzone, $xout, $yout) = |latlon-to-utm('WGS-84', :$zone, $yin, $xin);
# inline grid2page for speed
    #return grid2page($xout, $yout);
  ( ($xout + $xoffset) * $xscale + $xmin,
           ($yout + $yoffset) * $yscale + $ymin);
}

sub sbsb(Int $s1, Int $b1, Str $s2, Str $b2) {
    $TMP.print: qq:to 'EOF';
      /Helvetica-Latin1 4 selectfont
      ($b2) stringwidth pop ($b1) stringwidth pop add
      /Helvetica-Latin1 2 selectfont
      ($s1) stringwidth pop ($s2) stringwidth pop add add
      2 div neg 0 moveto
      ($s1) show
      /Helvetica-Latin1 4 selectfont ($b1) show
      /Helvetica-Latin1 2 selectfont ($s2) show
      /Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub lsbsb(Int $s1, Int $b1, Str $s2, Str $b2) {
    $TMP.print: qq:to 'EOF';
      0 0 moveto
      /Helvetica-Latin1 2 selectfont ($s1) show
      /Helvetica-Latin1 4 selectfont ($b1) show
      /Helvetica-Latin1 2 selectfont ($s2) show
      /Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub rsbsb(Int $s1, Int $b1, Str $s2, Str $b2) {
    $TMP.print: qq:to 'EOF';
      /Helvetica-Latin1 4 selectfont
      ($b2) stringwidth pop ($b1) stringwidth pop add
      /Helvetica-Latin1 2 selectfont
      ($s1) stringwidth pop ($s2) stringwidth pop add add
      neg 0 moveto
      ($s1) show
      /Helvetica-Latin1 4 selectfont ($b1) show
      /Helvetica-Latin1 2 selectfont ($s2) show
      /Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub latlon2string($val is copy, $dirs, $full is copy) {
    my $dir;
    if ($val < 0) {
	$val = - $val;
	$dir = $dirs.substr(1, 1);
    } else {
	$dir = $dirs.substr(0, 1);
    }
    $full = 1 if $val == $val.Int;
    $val += .01;
    my $int = $val.Int;
    my $frac = $val - $int;
    my $string = '';
    $string = "$int\\260 " if $full; # Assumes Latin1, not UTF8
    $frac = ($frac*60).Int;
    $string ~= sprintf "%02d'", $frac;
    $string ~= " $dir" if $full;
    $string;
}

# These functions do clever things to avoid plotting too many points
# outside the clipping boundary, while not literally cutting corners
# when a line moves back inside the clip boundary.

my Bool $moveto;
my Int  $quadrant = -1;
my Real $prev-x;
my Real $prev-y;

sub plot-point(Real $x, Real $y, Bool $moveto) {
    my ($x1, $y1) = latlon2page $x, $y;
    $TMP.print: sprintf "%.6g %.6g %s\n", $x1, $y1, $moveto ?? 'moveto' !! 'lineto';
}

my $prev-moveto;
sub plot-previous-point() {
    if $prev-x.defined and $prev-y.defined && !$prev-moveto {
	plot-point($prev-x, $prev-y, $prev-moveto);
	$prev-x = (Real);
	$prev-y = (Real);
    }
}

my ($minx, $miny, $maxx, $maxy);

sub add-point(Real $x, Real $y) {
    my $new-quadrant = 5;

    return unless $x.defined and $y.defined;

    $new-quadrant -= 1 if $x < $minx;
    $new-quadrant += 1 if $x > $maxx;
    $new-quadrant += 3 if $y < $miny;
    $new-quadrant -= 3 if $y > $maxy;
    
    if ($quadrant == 5 || $quadrant != $new-quadrant) {
	plot-previous-point() if $quadrant != 5;
	plot-point($x, $y, $moveto);
	$prev-x = Nil;
	$prev-y = Nil;
	$moveto = False;
    } else {
	$prev-x = $x;
	$prev-y = $y;
	$prev-moveto = $moveto;
    }
    $quadrant = $new-quadrant;
}

sub put-comment($comment) {
  $TMP.print: "% $comment\n";
}

sub put-line(Str $shape is copy, Str $func, $featurewidth = '') {
    $prev-x = Nil;
    $prev-y = Nil;

    my @segments = $shape.split: '),(';
#$TMP.print: "% ",  $shape, "\n";
    my $segno = 1;
    for @segments -> $segment {
$TMP.print: "% Segment ", $segno++, "\n";
	$quadrant = -1;
	$moveto = True;
        for $segment.comb: /\-?<[\d\.]>+/ -> $x, $y { # just extract the numbers and ignore anything else
	  add-point(+$x, +$y);
	}
	plot-previous-point() if $quadrant != 5;
    }
    plot-previous-point() if $quadrant != 5;
    $TMP.say: "$featurewidth $func";
    %dependencies{$func}++;
}

my $pg;
my $sth-sym;
my $sth-symb;

use experimental :cached;
sub get-symbol (Str $type, Str $ftype) is cached {
  my $symbol = 0;
  note "Looking for {$ftype}({$type})" if $debug >= 10;
  my $sym = 0;
  for $sth-sym.execute($type, $ftype).arrays -> $obj {
    $sym = $obj[0].Int;
    next unless $sym;
    $symbol = $sym;
    note "Found $sym" if $debug >= 10;
  }
  if !$symbol {
    note "Unknown $type symbol $ftype";
  }
  $symbol;
}

my ($lllong, $lllat, $urlong, $urlat);
my $rect;

my %areafeaturetypes;

sub draw-areas(Str $table, Str $columns, Str $geomcol) {
  note "$table areas..." if $debug >= 1;

  my @columns     = $columns.split: ':';
  my $selectcolumns = @columns.join: ', ';
  my $numfeatcols = +@columns;

  my $results = $pg.query("SELECT $selectcolumns, st_astext($geomcol) as shape
                             FROM $table
                            WHERE $geomcol && $rect
                          ");

  if $results {
      for $results.arrays -> $object {
	  my $shape = $object.pop;
	  my $featuretype = $object.join: ':';
	  
	  my $symbol = 0;
	  %areafeaturetypes{$table}{$featuretype}++;
	  if $featuretype ~~ /^\d+$/ {
	      $symbol = $featuretype;
	  } else {
	      for $sth-symb.execute($table, $featuretype, 'area').arrays -> $obj {
		  $symbol = $obj[0].Int;
	      }
	  }
	  
          one-message "No symbol found for table {$table} feature {$featuretype}(area)" if $symbol <= 0 && $debug >= 1;
	  next unless $symbol > 0;
	  ++$object-count;
	  put-line($shape.Str, "area$symbol", );
      }
  } else {
      note "Table $table not found";
  }
}

sub draw-ga-areas(Str $table) {
  note "$table areas..." if $debug >= 1;
  my $geomcol; # = %defaults<areageometry>;
  $geomcol = 'shape';
  my $results = $pg.query("SELECT symbol, st_astext($geomcol) as shape
                          FROM $table
                          WHERE $geomcol && $rect
                         ");
  
  if $results {
    
      for $results.arrays -> $object {
      my $symbol = $object[0].Int;
      my $shape = $object[1];
      
      next unless $symbol > 0;
      ++$object-count;
      put-line($shape, "area$symbol");
    }
  } else {
    note "$table not found";
  }
}

sub draw-treeden(Str $table) {
  note "tree-density areas..." if $debug >= 1;
  my $geomcol; # = %defaults{'areageometry'};
  $geomcol = 'geom';
  my $results = $pg.query("SELECT ftype_code, tree_den, st_astext($geomcol) as shape
                          FROM $table
                          WHERE $geomcol && $rect
                         ",
                         RaiseError => 0);

  if $results {
    
    for $results.arrays -> $object {
      my $ftype = $object[0];
      my $density = $object[1];
      my $shape = $object[2];
   
      my $symbol = get-symbol('area', ([~] $ftype, '_', $density).Str.lc);
      
      next unless $symbol > 0;
      ++$object-count;
      put-line($shape, "area$symbol");
    }
  } else {
    note "Table tree_density not found";
  }
}

my $powerlinestart = 1;
my $powerdirection = 1;
my $tickdirection = 0;

sub powerline(Real $x, Real $y, Real $angle, Real $width, Real $thick, Str $colour) {
    if ($powerlinestart) {
	$powerlinestart = 0;
	$powerdirection = 1;
	$TMP.say: "$x $y moveto";
    } else {
        $angle *= π / 180;
	my $nx = $x - $thick / 2 * sin($angle) * $powerdirection;
	my $ny = $y + $thick / 2 * cos($angle) * $powerdirection;
	$TMP.say: "$nx $ny lineto";
	$powerdirection = $powerdirection > 0 ?? -1 !! 1;
    }
}

sub leftticks(Real $x, Real $y, Real $angle, Real $width, Real $thick, Str $colour) {
    $TMP.say: "gsave $x $y translate $angle rotate $colour setcmykcolor $thick setlinewidth 0 0 moveto 0 $width lineto stroke grestore";
}

sub altticks(Real $x, Real $y, Real $angle, Real $width is rw, Real $thick, Str $colour) {
    $width *= -1 if $tickdirection;
    $TMP.say: "gsave $x $y translate $angle rotate $colour setcmykcolor $thick setlinewidth 0 0 moveto 0 $width lineto stroke grestore";
    $tickdirection = ! $tickdirection;
}

sub follow-line(Str $shape, $spacing, $func, Real $width, Real $thick, Str $colour) {
    my ($oldx, $oldy);
    my $counter = $spacing / 2;

    my @segments = $shape.split: '\)\,\s*\(';
    for @segments -> $segment {
	for $segment.comb(/(\-?<[\d.]>+)/) -> $lx, $ly {
	    my ($x, $y) = latlon2page $lx.Num, $ly.Num;
	    if ($oldx.defined) {
		my $deltax = $x - $oldx;
		my $deltay = $y - $oldy;
		my $length = sqrt($deltax * $deltax + $deltay * $deltay);
		if ($length >= $counter) {
		    my $angle = atan2($deltay, $deltax) * 180 / π;
		    loop (my $l  = $counter;
                             $l <= $length;
                             $l += $spacing) {
			my $frac = $l / $length;
			my $tx = $oldx + $deltax * $frac;
			my $ty = $oldy + $deltay * $frac;
			&$func($tx, $ty, $angle, $width, $thick, $colour);
			$counter -= $spacing;
		    }
		    $counter = $l - $length;
		} else {
		    $counter -= $length;
		}
	    }
	    $oldx = $x;
	    $oldy = $y;
	}
    }
}

#`[
  The various routines for drawing lines from various tables

  Common parts of these should be extracted.
]

my %funnylines = ();

%funnylines<57> = sub ($shape) { # Depression contour (index)
  put-line($shape, "line57A", 0);
  follow-line($shape, 4, &leftticks, .3, .2, '0 .59 1 .18');
}
%funnylines<58> = sub ($shape) { # Depression contour (standard)
  put-line($shape, "line58A", 0);
  follow-line($shape, 4, &leftticks, .3, .15, '0 .59 1 .18');
}
%funnylines<31> = sub ($shape) {} # Embankment
%funnylines<542> = sub ($shape) { # Powerline
  $powerlinestart = 1;
  follow-line($shape, .5, &powerline, .5, .2, '1 .73 0 0');
  $TMP.say: "1 .73 0 0 setcmykcolor .2 setlinewidth stroke";
}
%funnylines<543> = sub ($shape) { # Powerline
  $powerlinestart = 1;
  follow-line($shape, .5, &powerline, .5, .2, '.79 .9 0 0');
  $TMP.say: ".79 .9 0 0 setcmykcolor .2 setlinewidth stroke";
}
%funnylines<920> = sub ($shape) { # Cliff (WAC)
  put-line($shape, "line920A", 0);
  follow-line($shape, 1, &leftticks, .4, .15, '0 .59 1 .18');
}
%funnylines<923> = sub ($shape) {} # Cutting
%funnylines<924> = sub ($shape) { # Cliff
  put-line($shape, "line924A", 0);
  follow-line($shape, 1, &leftticks, .4, .15, '0 0 0 1');
}
%funnylines<929> = sub ($shape) { # Razorback
  put-line($shape, "line929A", 0);
  follow-line($shape, 1, &altticks, .4, .15, '0 0 0 1');
}

my %linefeaturetypes;

sub draw-lines(Str $table, Str $columns, Str $geomcol, $default, Str $widthcol) {
#    dd $table;
#    dd $columns;
#    dd $geomcol;
#    dd $default,
#    dd $widthcol;
  note "$table lines..." if $debug >= 1;

  my @columns     = $columns.split: ':';
  my $selectcolumns = @columns.join: ', ';
  my $numfeatcols = +@columns;
  $selectcolumns    ~= ',' ~ $widthcol if $widthcol;

  my $featurewidth = 0;

  my $results = $pg.query("SELECT $selectcolumns, st_astext($geomcol) as shape
                          FROM $table
                          WHERE $geomcol && $rect
                         ");
  
  if $results {
      
note "{$results.rows} objects from $table";
      for $results.arrays -> $object {
	  my $shape = $object.pop;
	  $featurewidth = $object.pop if $widthcol;
	  my $featuretype = $object.join: ':';
#dd $featuretype;
	  
	  my $symbol = $default;
	  %linefeaturetypes{$table}{$featuretype}++;
	  if ! $symbol || $symbol eq '0' {
note "Getting symbol: $table, $featuretype, line" if $debug > 15;
#dd $table;
#dd $featuretype;
	      for $sth-symb.execute($table, $featuretype, 'line').arrays -> $obj {
		  $symbol = $obj[0].Int;
	      }
	  }
	  note "draw-line: $table $featuretype $symbol" if $debug >= 10;
	  
	  
	  next unless $symbol > 0;
	  ++$object-count;
	  if %funnylines{$symbol}.defined {
              %funnylines{$symbol}($shape);
	  } else {
              put-line($shape.Str, "line$symbol", 0);
	  }
      }
  } else {
      note "Table $table not found";
  }
}

sub draw-contours(Str $table, Str $columns, Str $geomcol, Str $elevcol) {
  note "$table contours..." if $debug ≥ 1;
  note "Contour interval: $contourinterval" if $debug ≥ 5;

  my @columns       = $columns.split: ':';
  my $selectcolumns = @columns.join: ', ';
  my $numfeatcols   = +@columns;
  $selectcolumns   ~= ',' ~ $elevcol if $elevcol;

  my $elevation = $contourinterval;

  my $results = $pg.query("SELECT $selectcolumns, st_astext($geomcol) as shape
                             FROM $table
                            WHERE $geomcol && $rect
                          ");
  
  if $results {
      for $results.arrays -> $object {
	  my $shape = $object.pop;

	  if $elevcol {
            $elevation = $object.pop;
            next unless $elevation %% $contourinterval;
          }
      
	  my $featuretype = $object.join: ':';
	  
	  my $symbol = 0;
	  %linefeaturetypes{$table}{$featuretype}++;
	  if $featuretype ~~ /^\d+$/ {
              $symbol = $featuretype;
	  } else {
              for $sth-symb.execute($table, $featuretype, 'line').arrays -> $obj {
		  $symbol = $obj[0].Int;
              }
	  }
	  note "draw_line: $table $featuretype $symbol" if $debug >= 10;
	  
	  next unless $symbol > 0;
	  ++$object-count;
	  if %funnylines{$symbol}.defined {
              %funnylines{$symbol}($shape);
	  } else {
              put-line($shape.Str, "line$symbol", 0);
	  }
      }
  } else {
      note "Table $table not found";
  }
}

#`[
  sub draw-vm-lines -- draw lines from a Vicmap table
    $table          -- table name
    $typecolumn     -- the name of the column containing the type of the line
    $default-symbol -- if positive override the symbol to be used
]

sub draw-vm-lines(Str $table, Str $typecolumn, $default-symbol = 0) {
  note "$table lines..." if $debug >= 1;
  my $geomcol; # = %defaults{'linegeometry'};
  $geomcol = 'geom';
  my $results = $pg.query("SELECT $typecolumn, st_astext($geomcol) as shape
                          FROM $table
                          WHERE $geomcol && $rect
                         ");
  
  if $results {
    
      for $results.arrays -> $object {
	  my $ftype = $object[0];
	  my $shape = $object[1];
	  
	  my $ft = '';
	  $ft ~= $ftype;
	  my $symbol = 0;
	  if ($default-symbol.defined and $default-symbol > 0) {
	      $symbol = $default-symbol;
	  } else {
	      $symbol = get-symbol('line', $ft);
	  }
	  next unless $symbol > 0;
	  ++$object-count;
	  given $symbol {
              when  57 { # Depression contour (index)
		  put-line($shape, "line57A", 0);
		  follow-line($shape, 4, &leftticks, .3, .2, '0 .59 1 .18');
              }
              when  58 { # Depression contour (standard)
		  put-line($shape, "line58A", 0);
		  follow-line($shape, 4, &leftticks, .3, .15, '0 .59 1 .18');
              }
	      when  31 {} # Embankment
              when 542 { # Powerline
		  $powerlinestart = 1;
		  follow-line($shape, .5, &powerline, .5, .2, '1 .73 0 0');
		  $TMP.say: "1 .73 0 0 setcmykcolor .2 setlinewidth stroke";
              }
	      when 543 { # Powerline (WAC)
		  $powerlinestart = 1;
		  follow-line($shape, .5, &powerline, .5, .2, '.79 .9 0 0');
		  $TMP.say: ".79 .9 0 0 setcmykcolor .2 setlinewidth stroke";
              }
	      when 920 { # Cliff (WAC)
		  put-line($shape, "line920A", 0);
		  follow-line($shape, 1, &leftticks, .4, .15, '0 .59 1 .18');
              }
	      when 923 {} # Cutting
              when 924 { # Cliff
		  put-line($shape, "line924A", 0);
		  follow-line($shape, 1, &leftticks, .4, .15, '0 0 0 1');
              }
	      when 929 { # Razorback
		  put-line($shape, "line929A", 0);
		  follow-line($shape, 1, &altticks, .4, .15, '0 0 0 1');
              }
	      default {
		  put-line($shape.Str, "line$symbol", 0);
              }
	  }
      }
  } else {
      note "Table $table not found";
  }
}

#`[
  sub draw-ga-lines -- draw lines from a Geosciences Australia table
    $table          -- table name
    $typecolumn     -- the name of the column containing the type of the line
    $default-symbol -- if positive override the symbol to be used
]

sub draw-ga-lines(Str $table, Str $typecolumn, $default-symbol = 0) {
  note "$table ($default-symbol) lines..." if $debug >= 1;
  my $geomcol; # = %defaults{'linegeometry'};
  $geomcol = 'shape';
  note "Reading column $geomcol ($rect)" if $debug >= 1;
  my $results = $pg.query("SELECT symbol, st_astext($geomcol) AS shape
                          FROM $table
                          WHERE $geomcol && $rect
                         ");
  
  if $results {
    
      for $results.arrays -> $object {
      my $symbol = $object[0].Int;
      my $shape = $object[1];
      
      note $symbol if $debug >= 10;
      if $default-symbol > 0 {
	  $symbol = $default-symbol;
      }
      next unless $symbol > 0;
      ++$object-count;
      given $symbol {
          when  57 { # Depression contour (index)
              put-line($shape, "line57A", 0);
	      follow-line($shape, 4, &leftticks, .3, .2, '0 .59 1 .18');
          }
          when  58 { # Depression contour (standard)
              put-line($shape, "line58A", 0);
	      follow-line($shape, 4, &leftticks, .3, .15, '0 .59 1 .18');
          }
	  when  31 {} # Embankment
          when 542 { # Powerline
              $powerlinestart = 1;
              follow-line($shape, .5, &powerline, .5, .2, '1 .73 0 0');
              $TMP.say: "1 .73 0 0 setcmykcolor .2 setlinewidth stroke";
          }
	  when 543 { # Powerline (WAC)
              $powerlinestart = 1;
              follow-line($shape, .5, &powerline, .5, .2, '.79 .9 0 0');
              $TMP.say: ".79 .9 0 0 setcmykcolor .2 setlinewidth stroke";
          }
	  when 920 { # Cliff (WAC)
              put-line($shape, "line920A", 0);
              follow-line($shape, 1, &leftticks, .4, .15, '0 .59 1 .18');
          }
	  when 923 {} # Cutting
          when 924 { # Cliff
              put-line($shape, "line924A", 0);
              follow-line($shape, 1, &leftticks, .4, .15, '0 0 0 1');
          }
	  when 929 { # Razorback
              put-line($shape, "line929A", 0);
              follow-line($shape, 1, &altticks, .4, .15, '0 0 0 1');
          }
	  default {
              put-line($shape.Str, "line$symbol", 0);
          }
      }
      }
  } else {
      note "Table $table not found";
  }
}

sub put-outline(Str $text is copy, Real $x, Real $y, Real $size, Str $colour, Real $thickness) { 
    $text ~~ s:g/\\/\/\//;
    $text ~~ s:g/\(/\\\(/;
    $text ~~ s:g/\)/\\\)/;
    $TMP.print: sprintf "%f %f moveto (%s) /Helvetica findfont %f scalefont setfont stringwidth pop 2 div neg 0 rmoveto (%s) false charpath %s setcmykcolor %f setlinewidth stroke\n", $x, $y, $text, $size, $text, $colour, $thickness;
}

sub draw-polygon-outline-names(Str $table, Str $column, Real $size, Real $thickness, Str $colour) {
  note "$table outline names..." if $debug >= 1;
#  my $geomcol = %defaults{'areageometry'};
  my $geomcol = 'geom';
  my $results = $pg.query("SELECT $column AS name, st_astext(st_envelope($geomcol)) AS bbox
                          FROM $table
                          WHERE $geomcol && $rect
                         ");
  
  if $results {
    
    for $results.hashes -> $row {
	my $name  = $row<name>.Str;
	my $shape = $row<bbox>.Str;
	my @x = read-points($shape);
	my $centrex = (@x[0] + @x[4]) / 2;
	my $centrey = (@x[1] + @x[5]) / 2;
	note "Locality $name $centrex $centrey $shape" if $debug >= 1;
	my ($cx, $cy) = latlon2page($centrex, $centrey);
	my @text = $name.split: ' ';
	my $yoffset = (@text.end + 1)/2;
	for @text -> $text {
 	    put-outline $text, $cx, $cy+$yoffset, $size, $colour, $thickness;
 	    $yoffset -= $size;
 	}
	++$object-count;
    }
  } else {
      note "Table $table not found";
  }
}

sub draw-properties() {
    note "property lines..." if $debug >= 1;
    my $geomcol; # = %defaults{'linegeometry'};
    $geomcol = 'geom';
    my $sth = $pg.db.prepare("SELECT st_astext($geomcol) AS shape
                                FROM vm_property_view 
                                WHERE pfi = \$1
                             ");
    
    for @properties -> $property {
        for $sth.execute($property).arrays -> $object {
            my $shape = $object[0];
            ++$object-count;
            put-line($shape, 'line927', 0);
        }
    }
}

#`[
  sub draw-ga-wlines -- draw lines (with width) from a Geosciences Australia table
    $table          -- table name
]

sub draw-ga-wlines(Str $table) {
    note "$table lines..." if $debug >= 1;
   my $results = $pg.query("SELECT symbol, st_astext(shape) AS shape, featurewidth
                              FROM $table
                             WHERE shape && $rect
                          ");
    
   for $results.arrays -> $object {
	my $symbol = $object[0].Int;
	my $shape = $object[1];
	my $featurewidth = $object[3];
	$featurewidth = 0 unless $featurewidth.defined && $featurewidth;
	
	next unless $symbol > 0;
	++$object-count;
	if ($symbol == 57) { # Depression contour (index)
	} elsif ($symbol == 58) { # Depression contour (standard)
	} elsif ($symbol == 31) { # Embankment
	} elsif ($symbol == 542) { # Powerline
	} elsif ($symbol == 543) { # Powerline (WAC)
	} elsif ($symbol == 920) { # Cliff (WAC)
	} elsif ($symbol == 923) { # Cutting
	} elsif ($symbol == 924) { # Cliff
	} elsif ($symbol == 929) { # Razorback
	} else {
	    put-line($shape, "line$symbol", $featurewidth);
	}
    }
}

#`[
  Routines for drawing roads.

  These are more difficult than other lines because of dual carriageways
  where we need to draw a yellow line superinposed on a wider red line.

  Common features should be extracted from the various versions.
]

#`[
  sub draw-roads -- draw roads

  Note that the first "feature column" must give a unique identifier for that row
]

sub draw-roads(Str $table, Str $columns, Str $geomcol, $default, Str $widthcol) {
    my @dual;
    my $featurewidth = 0.7;
    
    note "Roads..." if $debug >= 1;
    my @columns       = $columns.split: ':';
    my $pid           = @columns.shift;
    my $selectcolumns = @columns.join: ', ';
    my $numfeatcols   = +@columns;
    $selectcolumns   ~= ', ' ~ $widthcol if $widthcol;
    
    my $results = $pg.query("SELECT $pid, $selectcolumns, st_astext($geomcol) as shape
                              FROM $table
                             WHERE $geomcol && $rect
                            ");
    
    if $results {
        for $results.arrays -> $object {
            my $pfi   = $object.shift;
	    my $shape = $object.pop;
	    $featurewidth = $object.pop if $widthcol;
	    my $featuretype = $object.join: ':';
            dd $featuretype;
	    
	    my $symbol = $default;
	    %linefeaturetypes{$table}{$featuretype}++;
	    if ! $symbol || $symbol eq '0' {
                note "Getting symbol: $table, $featuretype, line" if $debug > 15;
                #dd $table;
                #dd $featuretype;
	        for $sth-symb.execute($table, $featuretype, 'line').arrays -> $obj {
		    $symbol = $obj[0].Int;
	        }
	    }
	    note "draw-road: $table $featuretype $symbol" if $debug >= 10;
	    
            #        $roadnames.say: "VM{$objectid} $road-name" if $roadnames;
	    next unless $symbol > 0;
	    @dual.push: $pfi if $symbol == 250;
	    ++$object-count;
            #        put-comment($road-name);
            #        $symbol += 9000 if %emphasise-roads{$road-name}.defined;
	    put-line($shape, "line$symbol", $featurewidth);
        }
    }
    
    # Now go back and draw the yellow centre line on dual carriageways
    
    note "Centre lines of roads..." if $debug >= 1;
    
    my $query = "SELECT st_astext($geomcol) AS shape
                   FROM $table
                  WHERE $pid = <whatever>
                 ";
    my $sth = $pg.db.prepare("SELECT st_astext($geomcol) AS shape
                                FROM $table
                               WHERE $pid = \$1
                             ");                           
    for @dual -> $objectid {
	$results = $sth.execute($objectid);
	
	for $results.arrays -> $object {
	    my $shape  = $object[0];
	    
	    put-line($shape, 'line250A', 0.6);
	}
    }
}

#`[
  sub draw-vm-roads -- draw roads from the Vicmap database table tr-road
    no parameters
]

sub draw-vm-roads() {
    my @dual;
    my $featurewidth;

# Read in symbols
  my %roadsymbols;
  my $results = $pg.query("SELECT function, class, sealed, symbol
                          FROM   vm_road_types
                         ");
  for $results.arrays -> $sym {
    %roadsymbols{"{$sym[0]}:{$sym[1]}:{$sym[2]}"} = $sym[3].Int;
  }

    note "Roads..." if $debug >= 1;
     $results = $pg.query("SELECT pfi, ftype_code, class_code, dir_code, road_seal, div_rd, ezirdnmlbl, st_astext(geom) AS shape
                          FROM vm_tr_road
                          WHERE geom && $rect
                         ");
    
     for $results.arrays -> $object {

	my $objectid     = $object[0];
	my $ftype-code   = $object[1];
	my $featurewidth = 0.9;
        my $class        = $object[2];
        my $dir          = $object[3];
        my $sealed       = $object[4];
        my $divided      = $object[5];
	my $road-name    = $object[6];
	my $shape        = $object[7];
	
        $roadnames.say: "VM{$objectid} $road-name" if $roadnames;
        $sealed = $sealed == 1 ?? 's' !! 'u';
        my $symbol = %roadsymbols{"{$ftype-code}:{$class}:{$sealed}"} //
                     %roadsymbols{"{$ftype-code}::"}; # default
	note "Unknown road type \"{$ftype-code}:{$class}:{$sealed}\"" unless $symbol;
	next unless $symbol > 0;
	@dual.push: $objectid if $symbol == 250;
	++$object-count;
        put-comment($road-name);
        $symbol += 9000 if %emphasise-roads{$road-name}.defined;
	put-line($shape, "line$symbol", $featurewidth);
    }

# Now go back and draw the yellow centre line on dual carriageways

    note "Centre lines of roads..." if $debug >= 1;

    my $sth = $pg.db.prepare('SELECT ftype_code, st_astext(geom) AS shape
                             FROM vm_tr_road
                            WHERE pfi = $1
                          ');
    for @dual -> $objectid {
	$results = $sth.execute($objectid);
	
	for $results.arrays -> $object {
	    my $symbol = $object[0];
	    my $shape  = $object[1];
	    
	    put-line($shape, 'line250A', 0.6);
	}
    }
}

#`[
  sub draw-ga-roads -- draw roads from the Geoscience Australia database table roads
    no parameters
]

sub draw-ga-roads() {
    my @dual;
    my $featurewidth;

    note "Roads..." if $debug >= 1;
    my $geomcol; # = %defaults{'linegeometry'};
  $geomcol = 'shape';
    my $results = $pg.query("SELECT objectid, symbol, featurewidth, st_astext($geomcol) AS shape
                            FROM ga_roads
                            WHERE $geomcol && $rect
                           ");
    
    for $results.arrays -> $object {
	my $objectid     = $object[0];
	my $symbol       = $object[1].Int;
        my $featurewidth = $object[2];
	my $shape        = $object[3];
	$featurewidth = 0 unless $featurewidth.defined && $featurewidth;
	
	next unless so $symbol;
	@dual.push: $objectid if $symbol == 250;
	++$object-count;
	put-line($shape, "line$symbol", $featurewidth);
    }

# Now go back and draw the yellow centre line on dual carriageways

    note "Centre lines of roads..." if $debug >= 1;

    my $sth = $pg.db.prepare('SELECT symbol, st_astext(shape), featurewidth
                              FROM ga_Roads
                             WHERE objectid = $1
                           ');
    for @dual -> $objectid {
	$results = $sth.execute($objectid);
	
	for $results.arrays -> $object {
	    my $symbol       = $object[0].Int;
	    my $shape        = $object[1];
	    my $featurewidth = $object[2];
	    
	    put-line($shape, 'line250A', $featurewidth);
	}
    }
}

# Put this in the database somewhere

my %osmroads2ga = (
    'motorway'      => 250,
    'trunk'         => 250,
    'primary'       => 250,
    'motorway_link' => 251,
    'secondary'     => 251,
    'trunk'         => 251,
    'trunl_link'    => 256,
    'tertiary'      => 256,
    'unclassified'  => 257,
    'road'          => 257,
    'service'       => 257,
    'residential'   => 257,
    'track'         => 254,
    'footway'       => 22,
    'path'          => 22,
    'cycleway'      => 22,
    );

#`[
  sub draw-osmroads -- draw roads from the OpensStreetMap database table planet_osm_line
    no parameters

  roads in that table are lines where the highway column isn't empty
]

sub draw-osmroads() {
    my @dual;
    my $featurewidth = 0;

    note "OSMRoads..." if $debug >= 1;
    my $results = $pg.query("SELECT osm_id, highway, st_astext(way) AS shape
                            FROM planet_osm_line
                            WHERE highway IS NOT NULL
                              AND way && $rect
                           ");
    
    for $results.arrays -> $object {
	my $objectid = $object[0].Int;
	my $type = $object[1];
	my $shape = $object[2];
	my $symbol = %osmroads2ga{$type};
	if $symbol.defined {
	    $featurewidth = 0 unless $featurewidth.defined && $featurewidth;
	    
	    next unless $symbol;
	    @dual.push: $objectid if $symbol == 250;
	    ++$object-count;
	    put-line($shape, "line$symbol", $featurewidth);
	} else {
	    note "Unknown road type $type";
	}
    }

# Now go back and draw the yellow centre line on dual carriageways

    my $sth = $pg.db.prepare("SELECT st_astext(way) AS shape
                         FROM planet_osm_line
                         WHERE osm_id = ?
                        ");
    for @dual -> $objectid {
	$results = $sth.execute($objectid);
	
	for $results.arrays -> $object {
	    my $shape = $object[0];
	    
	    put-line($shape, 'line250A', $featurewidth);
	}
    }
}

#`[
  Routines for drawing points

  Once again, the commonality should be extracted
]

#`[
  sub draw-points -- draw points from a generic table
    $table -- database table
]

my %pointfeaturetypes;

sub draw-points(Str $table, Str $columns, Str $geomcol, Str $orientcol, Str $widthcol) {
  note "$table points..." if $debug >= 1;
  note $columns if $debug >= 5;

  my @columns     = $columns.split: ':';
  my $selectcolumns = @columns.join: ', ';
  my $numfeatcols = +@columns;
  $selectcolumns    ~= ',' ~ $orientcol if $orientcol;
  $selectcolumns    ~= ',' ~ $widthcol if $widthcol;

  my $featurewidth = 0;
  my $orientation  = 0;

  my $results;
  my $latlong = False;
  if $geomcol.index(':') {
    $latlong = True;
    my ($longcol, $latcol) = $geomcol.split(':');
    $results = $pg.query("SELECT $selectcolumns, $longcol, $latcol
                            FROM $table
                            WHERE $longcol > $lllong
                              AND $longcol < $urlong
                              AND $latcol  > $lllat
                              AND $latcol  < $urlat
                             ");
  } else {
    $results = $pg.query("SELECT $selectcolumns, st_astext($geomcol) AS position
                            FROM $table
			    WHERE {$geomcol} && $rect
			   ");
  }
    
  for $results.arrays -> $object {
    my $featuretype = '';
    for ^$numfeatcols {
      $featuretype ~= $object.shift ~ ':';
    }
    $featuretype ~~ s/\:$//;
    
    $featurewidth = $object.shift if $widthcol;
    $orientation  = $object.shift if $orientcol;
    
    my $long;
    my $lat;
    if $latlong {
      $long = +$object.shift;
      $lat  = +$object.shift;
    } else {
      my $position     = $object.shift;
      $position ~~ / \( ( \-? <[\d\.]>+) \s+ ( \-? <[\d\.]>+ ) <[,)]> /;
      $long = +$0;
      $lat = +$1;
    }
    my ($x, $y) = latlon2page +$long, +$lat;

    my $symbol = 0;
    %pointfeaturetypes{$table}{$featuretype}++;
    if $featuretype ~~ /^\d+$/ {
      $symbol = $featuretype;
    } else {
      for $sth-symb.execute($table, $featuretype, 'point').arrays -> $obj {
        $symbol = $obj[0].Int;
        one-message "No symbol found for table $table feature $featuretype" if $symbol <= 0 && $debug >= 1;
      }
    }
	
    #next unless @display-feature[$featuretype]; ### TODO
    next unless $symbol;
    ++$object-count;
    %dependencies{"point$symbol"}++;
    $TMP.print: sprintf("$orientation %.6g %.6g $featurewidth point$symbol\n", $x, $y);
  }
}

#`[
  sub draw-ga-points -- draw points from a Geoscience Australia table
    $table -- database table
]

sub draw-ga-points(Str $table) {
    note "$table ga-points..." if $debug >= 1;
  my $geomcol; # = %defaults{'pointgeometry'};
  $geomcol = 'position';

  note "SELECT symbol, st_astext($geomcol) AS position, orientation, featurewidth
                            FROM $table
			    WHERE $geomcol && $rect
			   ";
  my $results = $pg.query("SELECT symbol, st_astext($geomcol) AS position, orientation, featurewidth
                            FROM $table
			    WHERE $geomcol && $rect
			   ");
    
  for $results.arrays -> $object {
#dd $object;
	my $symbol       = $object[0].Int;
	my $position     = $object[1];
	my $orientation  = $object[2] || 0;
	my $featurewidth = $object[3];
	$featurewidth = 0 unless $featurewidth.defined && $featurewidth;

	next unless so $symbol;
	++$object-count;
	$position ~~ / \( ( \-? <[\d\.]>+) \s+ ( \-? <[\d\.]>+ ) \) /;
	my ($x, $y) = latlon2page +$0, +$1;
	%dependencies{"point$symbol"}++;
	$TMP.print: sprintf "$orientation %.6g %.6g $featurewidth point$symbol\n", $x, $y;
    }
}

#`[
  Routines for drawing text

  Once again, the commonality should be extracted
]

#`[
  sub draw-text -- draw text from a generic table
    $table      -- database table
    $textcolumn -- the column which contains the text to be printed
    $geomcol    -- the column which specifies where the text should go (subject to an offset)
    $widthcols  -- the column(s) which will be used to determine font, pointsize etc.
]

sub draw-text(Str $table, Str $textcolumn, Str $geomcol, Str $widthcols) {
  note "$table text..." if $debug >= 1;

  my $selectcolumns = $textcolumn;
  my @widthcols     = $widthcols.split: ':';
  my $numwidthcols  = +@widthcols;
  if $numwidthcols {
     $selectcolumns ~= ', ';
     $selectcolumns ~= @widthcols.join(', ');
  }

  my $results;
  my $latlong = False;
  if $geomcol.index(':') {
    $latlong = True;
    my ($longcol, $latcol) = $geomcol.split(':');
    $results = $pg.query("SELECT $selectcolumns, $longcol, $latcol
                            FROM $table
                            WHERE $longcol > $lllong
                              AND $longcol < $urlong
                              AND $latcol  > $lllat
                              AND $latcol  < $urlat
                             ");
  } else {
    $results = $pg.query("SELECT $selectcolumns, st_astext($geomcol) AS position
                            FROM $table
			    WHERE {$geomcol} && $rect
			   ");
  }
    
  for $results.arrays -> $object {
    my $text  = $object.shift;
    my $widthtype = '';
    for ^$numwidthcols {
      $widthtype ~= $object.shift ~ ':';
    }
    $widthtype ~~ s/\:$//;
    
    
    my $long;
    my $lat;
    if $latlong {
      $long = +$object.shift;
      $lat  = +$object.shift;
    } else {
      my $position     = $object.shift;
# TODO: generalise for line and polygon objects
      $position ~~ / \( ( \-? <[\d\.]>+) \s+ ( \-? <[\d\.]>+ ) \) /;
      $long = +$0;
      $lat = +$1;
    }
    my ($x, $y) = latlon2page +$long, +$lat;
    $x += 1; $y += 1; # offset text slightly

    my $width = 0;
    %pointfeaturetypes{$table}{$widthtype}++;
    if $widthtype ~~ /^\d+$/ {
      $width = $widthtype;
    } else {
      note "Getting text height for $table, $widthtype" if $debug ≥ 5;
      for $sth-symb.execute($table, $widthtype, 'text').arrays -> $obj {
        $width = $obj[0].Int;
      }
      note "Got $width" if $debug ≥ 5;
    }
	
    #next unless @display-feature[$featuretype]; ### TODO
    next unless $width;
    ++$object-count;
    $TMP.print: sprintf("0 0 0 1 setcmykcolor %.6g %.6g moveto /Arial findfont $width scalefont setfont ($text) show\n", $x, $y);
  }
}

sub draw-spot-heights() {
    note "spot heights..." if $debug >= 1;
  my $geomcol; # = %defaults{'pointgeometry'};
  $geomcol = 'geom';
    my $results = $pg.query("SELECT ftype_code, st_astext($geomcol) AS position, altitude
                            FROM vm_el_grnd_surface_point
                            WHERE $geomcol && $rect
                           ");
    
    $TMP.say: "/Helvetica-Latin1 2 selectfont 0 0 0 1 setcmykcolor";

    for $results.arrays -> $object {
        my $ftype    = $object[0];
        my $position = $object[1];
        my $altitude = $object[2] || 0;
        my $featuretype = $ftype;

        next unless $featuretype eq 'spot_height';
        
        $position ~~ / \( (\-?<[\d.]>+) \s+ (\-?<[\d.]>+) \) /;
        my ($x, $y) = latlon2page +$0, +$1;
        %dependencies<point52>++;
	$TMP.print: sprintf "0 %.6g %.6g 0 point52\n", $x, $y;
        $TMP.print: sprintf "%.6g %.6g moveto ($altitude) show newpath\n", $x+0.5, $y-0.5;
    }
}

my @road-widths = (.9, .9, .9, .6, .6, .6, .4, .4, .4, .4, .2, .2, .2);

sub draw-roadpoints() {
    note "vm_tr_road_infrastructure points..." if $debug >= 1;
    my $geomcol; # = %defaults{'pointgeometry'};
    $geomcol = 'geom';
    my $results = $pg.db.query("SELECT ftype_code, st_astext($geomcol) AS position, rotation, ufi
                                  FROM vm_tr_road_infrastructure
                                  WHERE $geomcol && $rect
                               ").array;
    my $sth2 = $pg.db.prepare('SELECT ftype_code, class_code
                             FROM vm_tr_road
                             WHERE from_ufi = $1
                                OR to_ufi = $2
                            ');
    
    if $results {
     
	for $results -> $object {

        my $ftype        = $object[0];
        my $position     = $object[1];
        my $orientation  = 90 - $object[2] || 0;
        my $ufi          = $object[3].Int;
        my $featurewidth  = 0;
        my $featuretype  = $ftype;
	
	my Str $ft = '';
        $ft ~= $ftype;
        my $symbol = get-symbol('point', $ft);
        
        #next unless @display-feature[$featuretype]; ### TODO
        next unless $symbol;
        ++$object-count;
        $position ~~ / \( (\-? <[\d.]>+) \s+ (\-? <[\d.]>+) \) /;
        my ($x, $y) = latlon2page +$0, +$1;
        %dependencies{"point$symbol"}++;
        if $featurewidth <= 0 {
	  # Find the width of the adjoining roads
	  my $adjcode = 12; # largest real class-code
	  for $sth2.execute($ufi, $ufi).arrays -> $obj {
	    $adjcode = $obj[1] if $obj[1] < $adjcode;
	  }
	  $featurewidth = @road-widths[$adjcode];
        }
	  $TMP.print: sprintf "$orientation %.6g %.6g $featurewidth point$symbol\n", $x, $y;
      }
    } else {
      note "Table vm_tr_road_infrastructure does not exist";
    }
}

my $debugannotation = True;

class Annotation {
  has $!length;
  has @!bytes;
  has $!index;

  my %tobin = ('0' => 0, '1' => 1, '2' => 2, '3' => 3,
               '4' => 4, '5' => 5, '6' => 6, '7' => 7,
               '8' => 8, '9' => 9,
	       'a' => 10, 'b' => 11, 'c' => 12, 'd' => 13, 'e' => 14, 'f' => 15,
	       'A' => 10, 'B' => 11, 'C' => 12, 'D' => 13, 'E' => 14, 'F' => 15
              );

  use experimental :pack;

  method start($annotation) {
    note $annotation if $debugannotation;
    $!index = 0;
    $!length = $annotation.elems;
    for ^$!length -> $i {
      @!bytes.push($annotation.subbuf($i, 1).unpack('C'));
    }
  }

  method skip(Int $skip) {
    note "skipping $skip bytes at $!index" if $debugannotation;
    $!index += $skip;
  }

  method byte {
    fail('annotation out of range') if $!index >= $!length;
    note "about to read byte number $!index (@!bytes[$!index])" if $debugannotation;
    @!bytes[$!index++];
  }

  method getbytes(Int $count) {
    note "getbytes $count from $!index" if $debugannotation;
    $!index += $count;
    @!bytes[($!index-$count) ..^ $!index - 1]>>.chr.join;
  }

  method getutf16(Int $count) {
    $!index += $count;
    my @utf16;
    for @!bytes[($!index-$count) ..^ $!index - 2] -> $l, $h { @utf16.push: $h*256 + $l };
    @utf16>>.chr.join;
  }

  method string {
    note "read string at $!index" if $debugannotation;
    my $length = self.int;
    note "reading string of length $length" if $debugannotation;
    self.getutf16($length);
  }

  method colour {
    my $cyan    = self.byte / 100;
    my $magenta = self.byte / 100;
    my $yellow  = self.byte / 100;
    my $black   = self.byte / 100;
    ($cyan, $magenta, $yellow, $black);
  }

  method astring {
    my $length = self.byte;
    self.getbytes($length);
  }

  method lastring {
    my $length = self.int;
    self.getbytes($length);
  }

  method short {
     $!index += 2;
     nativecast((int32), Blob.new(@!bytes[$!index-2 ..^ $!index]));
  }

  method int {
     $!index += 4;
     nativecast((int32), Blob.new(@!bytes[$!index-4 ..^ $!index]));
  }

  method double {
    $!index += 8;
    nativecast((num64), Blob.new(@!bytes[($!index-8) ..^ $!index]));
  }

}

sub draw-ga-annotations() {
    note "Annotations1...\n" if $debug >= 1;
    my $results = $pg.query("SELECT element, st_astext(shape) AS shape, objectid
                            FROM ga_annotations
                            WHERE shape && $rect
                           ");
    
    for $results.arrays -> $object {
note "Start loop" if $debugannotation;
        dd $object if $debugannotation;
	++$object-count;
	my $element  = $object[0];
	my $shape    = $object[1];
        my $objectid = $object[2].Int;
	my ($string2, $string3, $font);
	my ($x1, $y1, $x2, $y2);
	my $unknown1;
	my $justn = 0;
	my ($rotangle, $xdiff, $ydiff);
        note "Object ID: $objectid" if $debug >= 10;
	
    next if $objectid == 6651940;
	my $ann = Annotation.new();
        $ann.start($element);

# The following horrendous code is an attempt to extract data from the undocumented annotations in the Australian 1:250000 series maps
# It's also extremely slow :-(
	#{my $el = $element; while ($el) {$TMP.printf: "%02.2x ", ord(substr($el, 0, 1)); substr($el, 0, 1) = ''; } $TMP.print: "\n";}
	$ann.skip(54);
	$string2 = $ann.string;
	note "draw-ga-annotation: $string2" if $debug >= 10;
	$unknown1 = $ann.byte;
        $ann.skip(21);
	$unknown1 = $ann.byte;
        $ann.skip(15);
	$unknown1 = $ann.short();
	$unknown1 = $ann.short();
	my ($cyan, $magenta, $yellow, $black) = $ann.colour;
	#note "colour: $cyan $magenta $yellow $black\n" if $debug >= 10;
        $ann.skip(2);
	$unknown1 = $ann.int;
	$ann.skip(21) if ($unknown1 == 0);
	$unknown1 = $ann.int;
	$justn = $ann.int;
        $ann.skip(2);
	$rotangle = $ann.double;
	$xdiff = $ann.double;
	$ydiff = $ann.double;
        $ann.skip(110);
	$unknown1 = $ann.short;
        $ann.skip(61);
	$string3 = $ann.string;
        $ann.skip(6);
	#note "Second copy of string: $string3\n" if $debug >= 10;
	my $pointsize = $ann.byte;
	$pointsize = $pointsize / 4 * 25.4 / 72;
	#note "Point size: $pointsize\n" if $debug >= 10;
        $ann.skip(48);
	$unknown1 = $ann.byte;
	$unknown1 = $ann.short;
	$pointsize = $ann.int;
	$pointsize = $pointsize / 10000 * 25.4 / 72;
	$font = $ann.astring;
	#note "Font: $font\n" if $debug >= 10;
        $ann.skip(18);
	$unknown1 = $ann.byte;
	#$TMP.print: "unknown1: $unknown1\n"; ###
	if ($unknown1 == 16) {
            $ann.skip(17);
	    $unknown1 = $ann.short;
            $ann.skip(6);
	    $x1 = $ann.double;
	    $y1 = $ann.double;
	    $x2 = $ann.double;
	    $y2 = $ann.double;
	    #$TMP.print: "16: $x1 $y1 $x2 $y2\n"; ###
            $ann.skip(4);
	    my $count = $ann.int;
            $ann.skip(4);
	    #$TMP.print: "count: $count\n"; ###
	    if ($count) {
		my @coords = ();
		while ($count--) {
		    my $x = $ann.double;
		    my $y = $ann.double;
		    push @coords, [$x, $y];
		}
		($x1, $y1) = @(@coords[0]);
		($x2, $y2) = @(@coords[1]);
		if (%drawobjects{'annotation_position'}) {
                    my ($tx, $ty) = latlon2page($x1, $y1);
                    $TMP.print: "%%%%%%%\n$tx $ty moveto\n";
                    for @coords -> $posn {
                        my ($x, $y) = @$posn;
                        ($tx, $ty) = latlon2page($x, $y);
                        $TMP.print: "$tx $ty lineto\n";
                    }
                    $TMP.print: "1 1 0 0 setcmykcolor 0.5 setlinewidth stroke\n";
                }
                $xdiff = 0;
                $ydiff = 0;
                $justn = 0;
            }
        } elsif ($unknown1 == 65) {
            $ann.skip(17);
            $unknown1 = $ann.short;
            $ann.skip(6);
            $x1 = $ann.double;
            $y1 = $ann.double;
            #note "65: $x1 $y1\n" if $debug >= 10;
            if (%drawobjects{'annotation_position'}) {
                my ($tx, $ty) = latlon2page $x1, $y1;
                $TMP.print: "$tx $ty moveto 1 0 rlineto 1 1 0 0 setcmykcolor 0.5 setlinewidth stroke %%%%%\n";
            }
            $xdiff = $ydiff = 0;
        } else {
            note "Unknown annotation value $unknown1, ignoring\n";
            next;
        }
        $ann.skip(18);
        $ann.lastring;
        $ann.skip(41);
        
        note "Drawing annotation" if $debugannotation;
        # finished parsing; now print something
        
        # Check for valid location -- sometimes we get lat/lon with NaN values!
        if ($x1 == $x1 and $y1 == $y1) {
            $font = ($font eq 'Zurich Cn BT') ?? 'Helvetica-Narrow-Latin1' !! 'Helvetica-Latin1';
            $TMP.print: sprintf "/$font %.4g selectfont\n", $pointsize;
            
            my $annotation = $string2;
            ($x1, $y1) = latlon2page $x1, $y1;
            my $angle;
            if ($y2.defined) {
                ($x2, $y2) = latlon2page $x2, $y2;
                $angle = atan2($y2 - $y1, $x2 - $x1) * 180 / π;
            } else {
                $angle = 0;
            }
            # $angle = $rotangle if $rotangle;
           $annotation ~~ s:g/\\/\\\\/;
            $annotation ~~ s:g/\(/\\\(/;
            $annotation ~~ s:g/\)/\\\)/;
            $TMP.print: sprintf "gsave %.6g %.6g translate %.6g rotate 0 0 moveto %.4g %.4g %.4g %.4g setcmykcolor ", $x1+$xdiff, $y1+$ydiff, $angle, $cyan, $magenta, $yellow, $black;
            if ($justn == 2) {
                $TMP.print: "($annotation) stringwidth pop neg 0 rmoveto ";
            } elsif ($justn == 1) {
                $TMP.print: "($annotation) stringwidth pop 2 div neg 0 rmoveto ";
            }
            $TMP.print: "($annotation) show grestore\n";
        }
    }
}

sub draw-ga-annotations2() {
    note "Annotations2...\n" if $debug >= 1;
    note "  $lllong, $lllat, $urlong, $urlat" if $debug ≥ 1;
    my $results = $pg.query("SELECT annotation,
                                    longitude,
                                    latitude,
                                    orientation,
                                    colour,
                                    font,
                                    pointsize,
                                    justification
                               FROM ga_fixed_annotations
                              WHERE $lllong <= longitude
                                AND $urlong >= longitude
                                AND $lllat  <= latitude
                                AND $urlat  >= latitude
                           ");
    
    for $results.arrays -> $object {
        my $annotation    = $object[0];
        my $longitude     = $object[1];
        my $latitude      = $object[2];
        my $orientation   = $object[3];
        my $colour        = $object[4];
        my $font          = $object[5];
        my $textsize      = $object[6];
        my $justn         = $object[7];

note "Putting annotation $annotation";
        my ($x, $y) = latlon2page($longitude, $latitude);
        my $justification;
        given $justn {
            when 0 { $justification = 'lbl' }
            when 1 { $justification = 'lbc' }
            when 2 { $justification = 'lbr' }
            default { $justification = 'lbl' } # should probably raise an error
        }
        put-annotation($x, $y, $longitude, $latitude, 0, 0, $annotation, :$colour, :$textsize, linespacing => $textsize * 1.2, :$orientation, :$justification);
    }
}

sub draw-annotations($table) {
    note "Annotations...\n" if $debug >= 1;
    my $results = $pg.query("SELECT string, longitude, latitude, orientation,
                                    size, linespacing, position, colour,
                                    bboxcolour, bgcolour
                               FROM $table
                              WHERE $lllong <= longitude
                                AND $urlong >= longitude
                                AND $lllat  <= latitude
                                AND $urlat  >= latitude
                           ");
    
    for $results.arrays -> $object {
dd $object;
        dd $object if $debug ≥ 10;
	++$object-count;
	my $string        = $object[0];
	my $longitude     = $object[1];
	my $latitude      = $object[2];
	my $orientation   = $object[3];
	my $textsize      = $object[4];
	my $linespacing   = $object[5];
	my $justification = $object[6];
	my $colour        = $object[7];
	my $bboxcolour    = $object[8];
	my $bgcolour      = $object[9];

        my ($x, $y) = latlon2page($longitude, $latitude);
        put-annotation($x, $y, $longitude, $latitude, 0, 0, $string, :$colour, :$bboxcolour, :$bgcolour, :$textsize, :$linespacing, :$orientation, :$justification);
    }
}

my ($starteasting, $mineasting, $maxeasting, $startnorthing, $minnorthing, $maxnorthing);

sub label-grid(Bool $left, Bool $right) {
  my ($x, $y1, $y2);
  my ($lat, $long, $z);
  my $easting;
# Label grid lines
# Eastings below and above
  ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $starteasting, $minnorthing);
  ($x, $y1) = latlon2page($long, $lllatitude);
  $y1 -= 4;
  ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $starteasting, $maxnorthing);
  ($x, $y2) = latlon2page($long, $urlatitude);
  $y2 += 1;
  $TMP.print: "gsave $x $y1 translate ";
  my $a = $starteasting / $grid-spacing;
  my $b = ($a/10).Int;
  $a -= $b*10;
  sbsb($b.Int, $a.Int, '0 000m ', 'E');
  $TMP.say: " grestore";
  $TMP.print: "gsave $x $y2 translate ";
  sbsb($b.Int, $a.Int, '0 000m ', 'E');
  $TMP.print: " grestore\n";
  $easting = $starteasting + $grid-spacing;
    
  while ($easting <= $maxeasting) {
    ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $easting, $minnorthing);
    ($x, $y1) = latlon2page($long, $lllatitude);
    $y1 -= 4;
    ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $easting, $maxnorthing);
    ($x, $y2) = latlon2page($long, $urlatitude);
    $y2 += 1;
    if ! $bleedbottom {
      $TMP.print: "gsave $x $y1 translate\n";
      $a = $easting / $grid-spacing;
      $b = ($a/10).Int;
      $a -= $b*10;
      sbsb($b, $a.Int, '', '');
      $TMP.print: "grestore\n";
    }
    if ! $bleedtop {
      $TMP.print: "gsave $x $y2 translate\n";
      sbsb($b, $a.Int, '', '');
      $TMP.print: "grestore\n";
    }
    $easting += $grid-spacing;
  }
    
# Northings
  if $left and ! $bleedleft {
    my ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $mineasting, $startnorthing);
    my ($x, $y) = latlon2page($lllongitude, $lat);
    $x -= 1;
    my $a = $startnorthing / $grid-spacing;
    my $b = ($a/10).Int;
    $a -= $b * 10;
    $TMP.print: "gsave $x $y translate 90 rotate\n";
    sbsb($b, $a.Int, '0 000m ', 'N');
    $TMP.print: "grestore\n";
    my $northing = $startnorthing + $grid-spacing;
        
    while ($northing <= $maxnorthing) {
      ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $mineasting, $northing);
      ($x, $y) = latlon2page($lllongitude, $lat);
      $x -= 1;
      $y -= 2;
      $a = $northing / $grid-spacing;
      $b = ($a/10).Int;
      $a -= $b * 10;
      $TMP.print: "gsave $x $y translate\n";
      rsbsb($b, $a.Int, '', '');
      $TMP.print: "grestore\n";
      $northing += $grid-spacing;
    }
  }     
  if $right and ! $bleedright {
    my ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $maxeasting, $startnorthing);
    my ($x, $y) = latlon2page($urlongitude, $lat);
    $x += 4;
    my $a = $startnorthing / $grid-spacing;
    my $b = ($a/10).Int;
    $a -= $b * 10;
    $TMP.print: "gsave $x $y translate 90 rotate\n";
    sbsb($b, $a.Int, '0 000m ', 'N');
    $TMP.print: "grestore\n";
    my $northing = $startnorthing + $grid-spacing;
        
    while ($northing <= $maxnorthing) {
      ($lat, $long, $z) = |utm-to-latlon('WGS-84', $zone, $maxeasting, $northing);
      ($x, $y) = latlon2page($urlongitude, $lat);
      $x += 1;
      $y -= 2;
      $a = $northing / $grid-spacing;
      $b = ($a/10).Int;
      $a -= $b * 10;
      $TMP.print: "gsave $x $y translate\n";
      lsbsb($b, $a.Int, '', '');
      $TMP.print: "grestore\n";
      $northing += $grid-spacing;
    }
  }
}

sub label-graticule(Bool $left, Bool $right) {    
# Now label the lines of longitude and latitude:
    
    $TMP.print: "0 0 0 1 setcmykcolor /Helvetica-Latin1 4 selectfont\n";
    
    my $startlat = ($lllatitude/$graticule-spacing).Int * $graticule-spacing;
    $startlat += $graticule-spacing if $startlat < $lllatitude;
    my $startlong = ($lllongitude/$graticule-spacing).Int * $graticule-spacing;
    $startlong += $graticule-spacing if $startlong < $lllongitude;
    
# Longitude
    
    my $long = $startlong;
    
    my $first = 1;
    while ($long < $urlongitude + .0001) {
        my $lat = $lllatitude;
        my ($x, $y) = latlon2page $long, $lllatitude;
        my $string = latlon2string($long, "EW", $first);
        if ! $bleedbottom {
            $y -= 8;
            $TMP.print: "$x $y moveto ($string) dup stringwidth pop 2 div neg 0 rmoveto show\n" unless ($first && ! $left);
        }
        if ! $bleedtop {
          my ($x, $y) = latlon2page $long, $urlatitude;
          $y += 7;
          $TMP.print: "$x $y moveto ($string) dup stringwidth pop 2 div neg 0 rmoveto show\n" unless ($first && !$left);
        }
        $long += $graticule-spacing;
        $first = 0;
    }
    
# Latitude
    
    if ($left) {
        my $lat = $startlat;
        
        $first = 1;
        while ($lat < $urlatitude + .0001) {
            $TMP.print: "% Latitude $lat\n";
            my $long = $lllongitude;
            my ($x, $y) = latlon2page $long, $lat;
            $x -= 7;
            $y -= 2;
            my $string = latlon2string $lat, "NS", $first;
            $TMP.print: "$x $y moveto ($string) dup stringwidth pop neg 0 rmoveto show\n";
            $lat += $graticule-spacing;
            $first = 0;
        }
    }
    if ($right) {
        $TMP.print: "0 0 0 1 setcmykcolor /Helvetica-Latin1 4 selectfont\n";
# Latitude
        
        my $lat = $startlat;
        
        $first = 1;
        while ($lat < $urlatitude + .0001) {
            $TMP.print: "% Latitude $lat\n";
            my $long = $lllongitude;
            my $string = latlon2string $lat, "NS", $first;
            my ($x, $y) = latlon2page $urlongitude, $lat;
            $x += 7;
            $y -= 2;
            $TMP.print: "$x $y moveto ($string) show\n";
            $lat += $graticule-spacing;
            $first = 0;
        }
    }
}

# Draw the lines of longitude and latitude:

sub draw-graticule() {
    note "Drawing graticule..." if $debug >= 1;

    my $minlat = ($lllatitude/$graticule-spacing).Int * $graticule-spacing;
    $minlat += $graticule-spacing if $minlat < $lllatitude;
    my $minlong = ($lllongitude/$graticule-spacing).Int * $graticule-spacing;
    $minlong += $graticule-spacing if $minlong < $lllongitude;
    
# Longitude
    
    my $long = $minlong;
    
    while ($long < $urlongitude + .0001) {
        my $lat = $lllatitude;
        my ($x, $y) = latlon2page $long, $lat;
        $TMP.print: "% Longitude $long\n";
        $TMP.print: ".1 setlinewidth 0 0 0 1 setcmykcolor\n";
        $TMP.print: "$x $y moveto\n";
        $lat += 1.0/60.0;
        while ($lat <= $urlatitude + .0001) {
            ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y lineto\n";
            $lat += 1.0/60.0;
        }
        #$TMP.print: "stroke\n";
        $long += $graticule-spacing;
    }
    
# Longitude ticks
    
    $long = $minlong;
    
    while ($long < $urlongitude + .0001) {
        my $lat = (($lllatitude*60).Int)/60;;
        my ($x, $y) = latlon2page $long, $lat;
        while ($lat <= $urlatitude + .0001) {
            ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y moveto -.5 0 rlineto 1 0 rlineto stroke\n";
            $lat += 1.0/60.0; # FIX -- should relate to line spacing 
        }
        #$TMP.print: "stroke\n";
        $long += $graticule-spacing;
    }
    
    $long = $minlong;
    
    while ($long < $urlongitude + .0001) {
        my $lat = (($lllatitude*12).Int)/12;;
        my ($x, $y) = latlon2page $long, $lat;
        while ($lat <= $urlatitude + .0001) {
            ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y moveto -1 0 rlineto 2 0 rlineto stroke\n";
            $lat += 5.0/60.0; # FIX -- this is 1:250000 specific
        }
        #$TMP.print: "stroke\n";
        $long += $graticule-spacing;
    }
    
# Latitude
    
    my $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
        my $long = $lllongitude;
        my ($x, $y) = latlon2page $long, $lat;
        $TMP.print: "% Latitude $lat\n";
        $TMP.print: "$x $y moveto\n";
        $long += 1.0/60.0;
        while ($long <= $urlongitude + .1) {
            ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y lineto % $zone $long $lat\n";
            $long += 1.0/60.0;
        }
        #$TMP.print: "stroke % latitude\n";
        $lat += $graticule-spacing;
    }
    
# Latitude ticks
    
    $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
        my $long = ($lllongitude*60).Int/60;;
        while ($long <= $urlongitude + .0001) {
            my ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y moveto 0 -.5 rlineto 0 1 rlineto stroke\n";
            $long += 1.0/60.0;
        }
        $TMP.print: "stroke\n";
        $lat += $graticule-spacing;
    }
    
    $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
        my $long = ($lllongitude*12).Int/12;;
        while ($long <= $urlongitude + .0001) {
            my ($x, $y) = latlon2page $long, $lat;
            $TMP.print: "$x $y moveto 0 -1 rlineto 0 2 rlineto stroke\n";
            $long += 5.0/60.0;
        }
        $TMP.print: "stroke\n";
        $lat += $graticule-spacing;
    }
}
    
sub draw-grid() {
    note "Displaying grid..." if $debug >= 1;
    $TMP.say: "1 .1 0 .1 setcmykcolor\ngsave";

    $minnorthing = min($llnorthing, $lrnorthing);
    $startnorthing = (($minnorthing+($grid-spacing-1))/$grid-spacing).Int * $grid-spacing;
    $mineasting = min($lleasting, $uleasting);
    $starteasting = (($mineasting+($grid-spacing-1))/$grid-spacing).Int * $grid-spacing;
    my $maxeasting = max($lreasting, $ureasting);
    my $maxnorthing = max($ulnorthing, $urnorthing);
    
    $TMP.say: "% draw grid: $mineasting, $minnorthing to $maxeasting, $maxnorthing by $grid-spacing";
    my $easting = $starteasting;
    while ($easting <= $maxeasting) {
        my ($x1, $y1) = grid2page($easting, $minnorthing);
        my ($x2, $y2) = grid2page($easting, $maxnorthing);
        $TMP.print: "$x1 $y1 moveto $x2 $y2 lineto stroke\n";
        $easting += $grid-spacing;
    }
    
    my $northing = $startnorthing;
    while ($northing <= $maxnorthing) {
        my ($x1, $y1) = grid2page($mineasting, $northing);
        my ($x2, $y2) = grid2page($maxeasting, $northing);
        $TMP.print: "$x1 $y1 moveto $x2 $y2 lineto stroke\n";
        $northing += $grid-spacing;
    }
    $TMP.print: "grestore\n";
}

sub format-dms(Real $lat is copy, Str $pos, Str $neg) {
    my $string = '';
    my $hemisphere = $lat >= 0 ?? $pos !! $neg;
    $lat = - $lat if $lat < 0;
    my $deg = $lat.Int;
    $lat = ($lat-$deg) * 60;
    my $min = $lat.Int;
    my $sec = ($lat-$min) * 60;
    if ($sec >= 60) {
        $min++;
        $sec -= 60;
    }
    if ($min >= 60) {
        $deg++;
        $min -= 60;
    }
    $string = sprintf "%d\\260%d'%.2f\" %s", $deg, $min, $sec, $hemisphere; # ' # for editors which cannot parse strings properly
    $string;
}

sub format-lat(Real $lat) {
    format-dms($lat, 'N', 'S');
}

sub format-long(Real $long) {
    format-dms($long, 'E', 'W');
}

sub put-annotation(Real  $x, Real $y,             # where to position the text
		   Real  $long, Real $lat,        # latitude and longitude of point -- used only for interpolation into string
		   Real  $xoffset, Real $yoffset, # offset to text location (mm) -- arrow will be drawn from text to real position if a bbox is drawn
		   Str   $string is copy,         # string to print -- Latin 1
		   Str  :$colour        = '',     # text colour (CMYK)
		   Str  :$bboxcolour    = '',     # bounding box colour
		   Str  :$bgcolour      = '',     # in-fill colour, empty for none
		   Real :$textsize      = 1.5,    # font size (mm)
		   Real :$linespacing   = 2,      # line spacing (mm)
		   Real :$orientation   = 0,      # text orientation in degrees
                   Str  :$justification = 'ccc',  # lcr for horizontal position of box
                                                  # tcb for vertical position of box
		                                  # lcr for horizontal position of text inside box
		  ) {
    my $longstr = format-long($long);
    my $latstr  = format-lat($lat);
note "put-annotation: $x $y ($long ($longstr), $lat ($latstr) -- $xoffset, $yoffset) justification=$justification: $string";
    $string ~~ s:g/\$LONG/{$longstr}/;
    $string ~~ s:g/\$LAT/{$latstr}/;
    $string ~~ s:g/\\n/\n/;
    my @lines = $string.lines;

# draw line from point to text -- do this before any translations/rotations
# TODO: add arrowhead
    $TMP.print: "0.2 setlinewidth $bboxcolour setcmykcolor $x $y moveto $xoffset $yoffset rlineto stroke\n" if $bboxcolour && ($xoffset || $yoffset);
    
# Apply offsets
    my $pagex = $x + $xoffset;
    my $pagey = $y + $yoffset;
    
# Calculate box height
    my $height = (@lines.elems + 0.75) * $linespacing; # + 0.75 for top and bottom margins

# Calculate box width
    $TMP.print: "gsave 0\n"; # zero is initial max line width
    $TMP.print: "/Helvetica-Narrow-Latin1 $textsize selectfont\n"; # TODO: Allow other fonts
    for @lines -> $line {
	$TMP.say: "($line) stringwidth pop 2 copy lt \{exch\} if pop"
    }
    $TMP.print: "{$linespacing} add\n"; # add half linespacing on either side
    # top of stack is required box width

    $TMP.say: "$pagex $pagey translate $orientation rotate"; # Move to specified position and orientation

# move to allow centring etc
    
# Calculate horizontal position of text
    given $justification.comb[0] {
	when 'l' {
            $TMP.say: "0";
	}
	when 'c' {
            $TMP.say: "dup 2 div neg";
	}
	when 'r' {
            $TMP.say: "dup neg";
	}
        default {
            fail "Unknown horizontal annotation positioning code '$_'";
	}
    }

# Calculate vertical position of text
    given $justification.comb[1] {
	when 't' {
            $TMP.say: "0";
	}
	when 'c' {
            $TMP.say: "{$height/2}";
	}
	when 'b' {
            $TMP.say: "$height";
	}
        default {
            fail "Unknown vertical annotation positioning code '$_'";
	}
    }

    $TMP.say: "translate"; # origin is now top left corner of box

# Draw bounding box
    if $bboxcolour {
        $TMP.print: "0.2 setlinewidth 0 0  moveto dup 0 rlineto 0 $height neg rlineto dup neg 0 rlineto closepath gsave";
        if $bgcolour {
            $TMP.print: " $bgcolour setcmykcolor fill grestore";
        }
        $TMP.print: " $bboxcolour setcmykcolor stroke\n";
    }

# Move to where the actual text will be

    given $justification.comb[2] {
        when 'l' {
            $TMP.print: "{$linespacing / 2} {-$linespacing} translate\n";
        }
        when 'c' {
            $TMP.print: "dup 2 div {-$linespacing} translate\n";
        }
        when 'r' {
            $TMP.print: "dup {$linespacing / 2} sub {-$linespacing} translate\n";
        }
        # no need for default -- would have errored out before
    }
    
# Finally draw the text
#    $TMP.print: "2 div neg 1 add $height 2 div $textsize sub translate $colour setcmykcolor\n";
    $TMP.print: "$colour setcmykcolor\n";
    for @lines -> $line {
	$TMP.print: "0 0 moveto ($line) ";
        given $justification.comb[2] {
            when 'l' {
                # no need for anything here
            }
            when 'c' {
                $TMP.print: "dup stringwidth pop 2 div neg 0 rmoveto ";
            }
            when 'r' {
                $TMP.print: "dup stringwidth pop neg 0 rmoveto ";
            }
        }
        $TMP.print: "show 0 {-$linespacing} translate\n";
    }
    $TMP.print: "pop grestore\n";
}

my @ann;

sub draw-userannotations(Real $xoff, Real $yoff, Real $slopedeg) {
    my $slope = $slopedeg * π / 180;
    my $c = cos($slope);
    my $s = sin($slope);
    #note "cos theta: $c, sin theta: $s";
    #note "Draw-userannotation: $zone $xoff $yoff $slope";
    for @annotations -> $ann {
	next if %($ann)<long> < $lllongitude;
        next if %($ann)<long> > $urlongitude;
        next if %($ann)<lat>  < $lllatitude;
        next if %($ann)<lat>  > $urlatitude;
        my ($x, $y) = latlon2page %($ann)<long>, %($ann)<lat>;
        my ($x1, $y1) = ( $x * $c + $y * $s + $xoff * (1 - $c) - $yoff *    $s,
			 -$x * $s + $y * $c + $xoff *      $s  + $yoff * (1-$c));
	note "($x, $y) -> ($x1, $y1)";
        $($ann)<pagex> = $x1;
        $($ann)<pagey> = $y1;
        @ann.push: $ann;
    }
}

sub put-userannotations {
    for @ann -> $ann {
	put-annotation(%($ann)<pagex>,
	               %($ann)<pagey>,
		       %($ann)<long>,
                       %($ann)<lat>,
                       %($ann)<xoffset>,
                       %($ann)<yoffset>,
                       %($ann)<string>,
                       colour     =>'0 0 0 1', # default to black text
		       bboxcolour =>'0 0 0 1', # bbox colour
		       bgcolour   =>'0 0 0 0', # fill colour
                      ) if $lllong ≤ %($ann)<long> ≤ $urlong
                        && $lllat  ≤ %($ann)<lat>  ≤ $urlat;
    }
}

#`[
  sub draw-margins
    Bool $left  -- draw left hand side  (and map will be at left of page)
    Bool $right -- draw right hand side (and map will be at right of page)

  one or both of $left and $right must be true

  Returns a slip consisting of
    X offset of lower left corner     -- used for placement on page
    Y offset of lower left corner     -- used for placement on page
    slope of "centre" edge in degrees -- used for aligning annotations

  Draw the margins of (part of a) map,
    including the labels along the relevant edge
]

sub draw-margins(Bool $left, Bool $right) {
    my ($xoff, $yoff, $slope);

    (*, $xoffset, $yoffset)
	= |latlon-to-utm('WGS-84', :$zone, $lllatitude, $lllongitude);
    
    $xoffset = -$xoffset;
    $yoffset = -$yoffset;
    
    $TMP.say: "save 1 .1 0 .1 setcmykcolor % draw margins";
	
    $minnorthing = min($llnorthing, $lrnorthing);
    $maxnorthing = max($ulnorthing, $urnorthing);
    $mineasting  = min($lleasting,  $lreasting);
    $maxeasting  = max($uleasting,  $ureasting);
    $startnorthing
	= (($minnorthing+($grid-spacing-1))/$grid-spacing).Int * $grid-spacing;
    $starteasting
	= (($mineasting+($grid-spacing-1))/$grid-spacing).Int * $grid-spacing;
    if ($ongraticule) {
	if ($left) { # Calculate slope and position of right hand side
	    my ($x1, $y1) = latlon2page($urlongitude, $lllatitude);
	    my ($x2, $y2) = latlon2page($urlongitude, $urlatitude);
	    $slope = atan2($y2-$y1, $x2-$x1) * 180 / π - 90;
	    note "Right hand edge from ($x1, $y1) to ($x2, $y2), slope $slope" if $debug ≥ 1;
	    $TMP.print: sprintf
		"$x1 $y1 translate %f rotate $x1 neg $y1 neg translate\n", -$slope;
	    $xoff = $x1;
	    $yoff = $y1;
	} else { # Calculate slope and position of left hand side
	    my ($x3, $y3) = latlon2page($lllongitude, $lllatitude);
	    my ($x4, $y4) = latlon2page($lllongitude, $urlatitude);
	    $slope = atan2($y4-$y3, $x4-$x3) * 180 / π - 90;
	    note "Left hand edge from ($x3, $y3) to ($x4, $y4), slope $slope" if $debug ≥ 1;
	    $xoff = $x3;
	    $yoff = $y4;
	    $TMP.print:
		sprintf "$xoff $yoff translate %f rotate $xmin neg $ymin neg translate\n", -$slope;
	}
    }
    
    label-grid($left, $right)      if %drawobjects<grid>.defined;
    label-graticule($left, $right) if %drawobjects<graticule>.defined;

    |($xoff, $yoff, $slope); # return a slip
}

# Draw the bounding box, remembering the path which then becomes the clip path
    
sub draw-bbox() {
    if ($ongraticule) {
	my $long = $lllongitude;
	my $lat = $lllatitude;
	my ($x, $y) = latlon2page($long, $lat);
	$TMP.say: "$x $y moveto";
	$long += 1/60;
	while $long < $urlongitude {
	    ($x, $y) = latlon2page($long, $lat);
	    $TMP.say: "$x $y lineto";
	    $long += 1/60;
	}
	$long = $urlongitude;
	($x, $y) = latlon2page($long, $lat);
	$TMP.say: "$x $y lineto"; ### moveto???
	
	$lat += 1/60;
	while ($lat <= $urlatitude) {
	    ($x, $y) = latlon2page($long, $lat);
	    $TMP.print: "$x $y lineto\n";
	    $lat += 1/60;
	}
	$lat = $urlatitude;
	($x, $y) = latlon2page($long, $lat);
	$TMP.print: "$x $y lineto\n";
	
	$long -= 1/60;
	while ($long > $lllongitude) {
	    ($x, $y) = latlon2page($long, $lat);
	    $TMP.print: "$x $y lineto\n";
	    $long -= 1/60;
	}
	$long = $lllongitude;
	($x, $y) = latlon2page($long, $lat);
	$TMP.print: "$x $y lineto\n";
	
	$lat -= 1/60;
	while ($lat > $lllatitude) {
	    ($x, $y) = latlon2page($long, $lat);
	    $TMP.print: "$x $y lineto\n";
	    $lat -= 1/60;
	}
    } else { # on grid
	my ($x, $y) = grid2page($lleasting, $llnorthing);
	$TMP.print: "$x $y moveto\n";
        ($x, $y) = grid2page($lreasting, $lrnorthing);
        $TMP.print: "$x $y lineto\n";
        ($x, $y) = grid2page($ureasting, $urnorthing);
        $TMP.print: "$x $y lineto\n";
        ($x, $y) = grid2page($uleasting, $ulnorthing);
        $TMP.print: "$x $y lineto\n";
    }
}

# Fetch and display all the objects
    
sub draw-objects(Real $xoff, Real $yoff, Real $slope) {
    my $results = $pg.query("SELECT featurename, drawtype, tablename, featurecolumn, geomcol,
                                        orientcol, widthcol, defaultsymbol, displayorder
                                 FROM displayorder
                                 ORDER BY displayorder
                                ");

    for $results.arrays -> $object {
      my $feature     = $object.shift // '';
      my $draw        = $object.shift;
      my $table       = $object.shift // '';
      my $typecolumn  = $object.shift // '';
      my $geomcol     = $object.shift // '';
      my $orientcol   = $object.shift // '';
      my $widthcol    = $object.shift // '';
      my $default     = $object.shift // '';
      my $order       = $object.shift.Int;
      $default        = 0 unless $default.defined && $default;
      note "Drawing $feature: '$draw' '$table' '$typecolumn' ($order)" if $debug ≥ 1;
      if $order > 0 && %drawobjects{$feature.lc} {
        given $draw {
          when 'point'          { draw-points\              ($table, $typecolumn, $geomcol, $orientcol, $widthcol ); }
          when 'line'           { draw-lines\               ($table, $typecolumn, $geomcol, $default,   $widthcol ); }
          when 'road'           { draw-roads\               ($table, $typecolumn, $geomcol, $default,   $widthcol ); }
          when 'ga_line'        { draw-lines\               ($table, $typecolumn, $geomcol, $default,   $widthcol ); }
          when 'area'           { draw-areas\               ($table, $typecolumn, $geomcol,                       ); }
          when 'text'           { draw-text\                ($table, $typecolumn, $geomcol,             $widthcol ); }
          when 'contour'        { draw-contours\            ($table, $typecolumn, $geomcol,             $widthcol ); } # widthcol is contour elevation
          when 'outline'        { draw-polygon-outline-names($table, $typecolumn, 8, 0.2, '1 0 .86 0'             ); } # typecolumn is text to print
          when 'property'       { draw-properties\          (                                                     ); }
          when 'spotheight'     { draw-spot-heights\        (                                                     ); }
          when 'roadpoint'      { draw-roadpoints\          (                                                     ); }
          when 'treeden'        { draw-treeden\             ($table                                               ); }
          when 'graticule'      { draw-graticule\           (                                                     ); }
          when 'grid'           { draw-grid\                (                                                     ); }
          when 'annotation'     { draw-annotations\         ($table                                               ); }
          when 'ga_annotation'  { draw-ga-annotations2\     (                                                     ); }
          when 'userannotation' { draw-userannotations\     ($xoff, $yoff, $slope                                 ); }
          when 'ga_area'        { draw-ga-areas\            ($table                                               ); }
          when 'vm_road'        { draw-vm-roads\            (                                                     ); }
          when 'ga_road'        { draw-ga-roads\            (                                                     ); }
          when 'osm_road'       { draw-osmroads\            (                                                     ); }
          when 'ga_wline'       { draw-ga-wlines\           ($table,                                              ); }
          when 'ga_point'       { draw-ga-points\           ($table,                                              ); }
          default               { note "Unknown draw type $draw for feature $feature: object ignored"; }
        }
        } else {
	  note "Ignoring $feature" if $debug ≥ 5;
	}
    }
}


sub drawit(Str $drawzone, Real $d-lllong, Real $d-lllat, Real $d-urlong, Real $d-urlat, Bool $left, Bool $right) {
    $zone = $drawzone;
    my ($tlllong, $turlong, $tlllat, $turlat)
	= ($lllongitude, $urlongitude, $lllatitude, $urlatitude);
    ($lllongitude, $urlongitude, $lllatitude, $urlatitude)
	= ($d-lllong, $d-urlong, $d-lllat, $d-urlat);
    note "drawit: $zone $lllongitude $lllatitude $urlongitude $urlatitude $left $right" if $debug ≥ 1;

    ($lllong, $lllat, $urlong, $urlat) = ($lllongitude - 0.01,
                                          $lllatitude - 0.01,
                                          $urlongitude + 0.01,
                                          $urlatitude + 0.01
	            );

    $rect = "ST_GeometryFromText('POLYGON(($lllong $lllat, $urlong $lllat, $urlong $urlat, $lllong $urlat, $lllong $lllat))', 4326)"; # 4283)";

    my ($xoff, $yoff, $slope) = draw-margins($left, $right);
    draw-bbox();

    $TMP.say: 'closepath';
    $TMP.say: '.1 setlinewidth 0 0 0 1 setcmykcolor gsave stroke grestore' if %drawobjects<graticule>;
    $TMP.say: 'clip newpath';
    
    draw-objects($xoff, $yoff, $slope);

    put-userannotations();

    $TMP.say: 'restore % undo clip path'; # undo the clip path
    ($lllongitude, $urlongitude, $lllatitude, $urlatitude) = ($tlllong, $turlong, $tlllat, $turlat);
}

# Print out the Postscript definitions needed by this map

my %done-deps = ();

sub do-dependencies() {
  my $sth = $pg.db.prepare("SELECT dependencies, body
                          FROM $symbols
                          WHERE name = \$1
                         ");
  for keys %dependencies -> $dep {
    do-dependency($sth, $dep);
  }
}

sub do-dependency($sth is copy, Str $dependency) {
    return if %done-deps{$dependency}.defined;

    note "Dependency: $dependency" if $debug ≥ 1;    
    
    for $sth.execute($dependency).arrays -> $dep {;
	my $deps = $dep[0];
	my $body = $dep[1];
	if ($deps) {
	    my @deps = $deps.words;
	    for @deps -> $dep {
		do-dependency($sth, $dep) unless %done-deps{$dep}.defined;
	    }
	}
	print $body;
	%done-deps{$dependency} = 1;
    }
}

# START RUNNING HERE -- everything is defined

set-papersizes();

for %*ENV<HOME> ~ '/.mkmap.rc', '.mkmap.rc' -> $cfgfile {
  note "Handling config file $cfgfile" if $debug ≥ 1;
  process-option-file($cfgfile, 0); # 0 -> not an error if the file doesn't exist
}

for @*ARGS -> $arg {
    process-option($arg);
}

sub draw-map {
# Calculate various things which depend on the options

  my $leftmargin   = $bleedleft   ?? -10 !! $leftmarginwidth;
  my $rightmargin  = $bleedright  ?? -10 !! $rightmarginwidth;
  my $topmargin    = $bleedtop    ?? -10 !! $uppermarginwidth;
  my $bottommargin = $bleedbottom ?? -10 !! $lowermarginwidth;
  my $gratheight   = $graticuleheight;
  my $gratwidth    = $graticulewidth;

#FIX for multiple pages
  fail 'Must use either grid coordinates or lat/lon; not a mixture' if $ongrid && $ongraticule;
  fail "Unknown paper size $papersize" unless %papersizes{$papersize}.defined;

  $*OUT = $outputfile.IO.open(:w) if $outputfile.defined;

  given $orientation {
    when 'portrait'
      { ($paperwidth, $paperheight) = %papersizes{$papersize}.split(','); }
    when 'landscape'
      { ($paperheight, $paperwidth) = %papersizes{$papersize}.split(','); }
    default
      { fail "Unknown paper orientation $orientation\n"; }
  }
  if $debug ≥ 1 {
    note "Orientation is \"$orientation\"";
    note "Page width: $paperwidth, height $paperheight";
    note "Margins (tblr): $topmargin, $bottommargin, $leftmargin, $rightmargin";
    note "Bleed top/bottom/left/right: $bleedtop, $bleedbottom, $bleedleft, $bleedright";
  }
  my $imagewidth  = ($paperwidth  - $leftmargin   - $rightmargin) * $scale/1000;
  my $imageheight = ($paperheight - $bottommargin - $topmargin)   * $scale/1000;

# Work out where the corners are

  if ($ongraticule) {
    fail "No location specified" unless $lllongitude.defined && $lllatitude.defined;
    if $zone.defined && $zone ne '' {
      (*, $lleasting, $llnorthing)
	      = |latlon-to-utm('WGS-84', :$zone, $lllatitude, $lllongitude);
      note "Calculated grid as $lleasting:$llnorthing from lat $lllatitude long $lllongitude zone $zone" if $debug >= 2;
    } else {
      ($zone, $lleasting, $llnorthing)
	      = |latlon-to-utm('WGS-84', $lllatitude, $lllongitude);
      note "Calculated grid as $lleasting:$llnorthing from lat $lllatitude long $lllongitude calculated zone $zone" if $debug >= 2;
    }
    if (! $gratwidth.defined) {
      my ($tlat, $tlong, Nil)
	      = |utm-to-latlon('WGS-84', $zone, $lleasting+$imagewidth, $llnorthing);
      $gratwidth = $tlong - $lllongitude;
      note "Calculated graticule width as $tlong - $lllongitude ($lleasting $llnorthing $imagewidth) tlat = $tlat" if $debug ≥ 2;
    }
    if (! $gratheight.defined) {
      my ($tlat, $tlong, Nil)
	      = |utm-to-latlon('WGS-84', $zone, $lleasting, $llnorthing+$imageheight);
      $gratheight = $tlat - $lllatitude;
    }
    $lrlongitude = $urlongitude = $lllongitude + $gratwidth;
    $ullatitude = $urlatitude = $lllatitude + $gratheight;
    $ullongitude = $lllongitude;
    $lrlatitude = $lllatitude;
    note "$gratwidth, $gratheight: $lrlongitude $ullatitude $ullongitude $lrlatitude";
    (*, $lleasting, $llnorthing) = |latlon-to-utm('WGS-84', :$zone, $lllatitude, $lllongitude);
    (*, $lreasting, $lrnorthing) = |latlon-to-utm('WGS-84', :$zone, $lrlatitude, $lrlongitude);
    (*, $uleasting, $ulnorthing) = |latlon-to-utm('WGS-84', :$zone, $ullatitude, $ullongitude);
    (*, $ureasting, $urnorthing) = |latlon-to-utm('WGS-84', :$zone, $urlatitude, $urlongitude);
  } else { # on grid
    if (! $lleasting.defined or ! $llnorthing.defined or ! $zone.defined) {
      fail "No location specified\n";
    }
    if (! $gridwidth.defined) {
      $gridwidth = $imagewidth;
    }
    if (! $gridheight.defined) {
      $gridheight = $imageheight;
    }
    $ureasting = $lreasting = $lleasting + $gridwidth;
    $uleasting = $lleasting;
    $urnorthing = $ulnorthing = $llnorthing + $gridheight;
    $lrnorthing = $llnorthing;
    note "About to calculate bounding box (zone $zone)";
    ($lllatitude, $lllongitude, Nil) = |utm-to-latlon('WGS-84', $zone, $lleasting, $llnorthing);
    ($lrlatitude, $lrlongitude, Nil) = |utm-to-latlon('WGS-84', $zone, $lreasting, $lrnorthing);
    ($ullatitude, $ullongitude, Nil) = |utm-to-latlon('WGS-84', $zone, $uleasting, $ulnorthing);
    ($urlatitude, $urlongitude, Nil) = |utm-to-latlon('WGS-84', $zone, $ureasting, $urnorthing);
    note "$lllatitude $lllongitude $urlatitude $urlongitude\n";
  }

  note qq:to 'EOF' if $debug ≥ 1;
Grid corners:
    $uleasting $ulnorthing   $ureasting $urnorthing
    $lleasting $llnorthing   $lreasting $lrnorthing
EOF

  my $tmpfile = '/tmp/' ~ $*PID.Str;
  $TMP = $tmpfile.IO.open(:a) or fail "Could not open /tmp/$*PID: $!";

  $xmin = $leftmargin;
  $ymin = $bottommargin;
  # The following four variables are used to do rough clipping during drawing
  $minx = $lllongitude - .001;
  $maxx = $urlongitude + .001;
  $miny = $lllatitude  - .001;
  $maxy = $urlatitude  + .001;

  $yscale = $xscale = 1000/$scale; # convert metres on the ground to mm on the map

  %dependencies = ();
  %done-deps    = ();

  # Connect to database
  my $passwd = 'xyz123';
  note "Connecting to database $db";
  $pg = DB::Pg.new(conninfo => "dbname=$db");

  $sth-symb = $pg.db.prepare('SELECT symbol
                                FROM symbols
                               WHERE dbtable = $1
                                 AND featuretype = $2
                                 AND type = $3
                             ');

  $copyright = 'copyright'; # %defaults<copyright>;

  postscript-prefix();

  # Set up lists of object types (for use by display/nodisplay arguments)
  my $results = $pg.query('SELECT featurename
                           FROM displayorder
                          ');
  for $results.arrays -> $ftype {
    %allobjects{$ftype[0].lc} = 1;
  }
  %drawobjects = %allobjects;

  # Now we can handle the [no]display[all] options

  for @displays -> $arg {
      given $arg {
          when m:i/^display '=' all$/ {
              for keys %allobjects -> $type
    	      {
                  %drawobjects{$type} = 1;
              }
          }
          when m:i/^display '=' (\S+)$/ {
              %drawobjects{$0.lc} = 1;
          }
          when m:i/^nodisplay '=' all$/ {
              %drawobjects = ();
          }
          when m:i/^nodisplay '=' (\S+)$/ {
              %drawobjects{$0.lc} = 0;
          }
          when m:i/^nodisplayall '=' (\S+)$/ {
              my $hide = $0;
              for keys %allobjects -> $type
              {
                  %drawobjects{$type} = 0 if $type ~~ /^<$hide>.*$/;
              }
          }
          when m:i/^displayall '=' (\S+)$/ {
              my $show = $0;
              for keys %allobjects -> $type
              {
                  %drawobjects{$type} = 1 if $type ~~ /^<$show>.*$/;
              }
          }
      }
  }

  $sth-sym = $pg.db.prepare('SELECT symbol_ga
                           FROM vicmap_symbols
                           WHERE type = $1
                           AND ftype = $2
                          ');

  my ($leftzone, $rightzone);

  if (!$zone.defined && $ongraticule) {
    ($leftzone,  *, *) = |latlon-to-utm('WGS-84', $lllatitude, $lllongitude+.0000001);
    ($rightzone, *, *) = |latlon-to-utm('WGS-84', $urlatitude, $urlongitude-.0000001);
  } else {
    $leftzone = $rightzone = $zone;
  }

  if ($leftzone eq $rightzone) {
    drawit($leftzone, $lllongitude, $lllatitude, $urlongitude, $urlatitude, True, True);
  } else {
    my $boundary = $urlongitude.Int; # works for maps less than 1 degree wide -- FIX
    drawit($leftzone,  $lllongitude, $lllatitude, $boundary, $urlatitude, True, False);
    drawit($rightzone, $boundary, $lllatitude, $urlongitude, $urlatitude, False, True);
  }

  do-dependencies();

#  $pg.dispose();

  $TMP.close;
  $TMP = $tmpfile.IO.open(:r);
  .say for $TMP.lines;
  $TMP.close;
  unlink $tmpfile;

  say "showpage";

  note "$object-count objects, $point-count points\n";

  if $debug ≥ 1 {
  note "areas:";
  for %areafeaturetypes.keys -> $k {
    for %areafeaturetypes{$k}.keys ->$f {
      note "$k:$f";
    }
  }

  note "lines:";
    for %linefeaturetypes.keys -> $k {
      for %linefeaturetypes{$k}.keys -> $f {
        note "$k:$f";
      }
    }
    note "points:";
    for %pointfeaturetypes.keys -> $k {
      for %pointfeaturetypes{$k}.keys -> $f {
        note "$k:$f";
      }
    }
  }
  $*OUT.close if $outputfile.defined;
}

# If we ever get to here, we need to draw a map -- all the options should be set
draw-map();

# vi: filetype=perl6:
#!/usr/bin/perl6

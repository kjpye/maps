#!/usr/bin/env raku

use v6.c+;

use NativeCall;
use DB::Pg;

my $dbg = 0;

# Define some useful debugging routines
#
# These should be moved to a separate module

sub dump-hex(@bytes, $width) {
    $*ERR.print: (@bytes.map: {sprintf "%02.2x", $_}).join(' ');
    $*ERR.print: '   ' x max(0, $width - @bytes.elems);
}

sub dump-ascii(@bytes, $width) {
    $*ERR.print: '<';
    $*ERR.print: (@bytes.map:{ $_ ~~ 32..126 ?? $_.chr !! '.' }).join('');
    $*ERR.print: ' ' x max(0, $width - @bytes.elems);
    $*ERR.print: '>';
}

sub hex-dump(@bytes, $start, $count) {
    $*ERR.printf: "%08.8x ", $start;
    dump-hex(@bytes, $count);
    $*ERR.print: '  ';
    dump-ascii(@bytes, $count);
    $*ERR.print: "\n";
}

sub dump-blob($blob, $start is copy, $width = 16) {
    my $bytes = $blob.elems;
    my $offset = 0;
    while $bytes > 0 {
        my @bytes = $blob.subbuf($offset, $width).list;
        hex-dump(@bytes, $start, $width);
        $start += $width;
        $offset += $width;
        $bytes -= $width;
    }
}

constant PGSIZE = 4096;

my $inputfh;
my $input-lock = Lock.new();

sub read-page($page-num) {
    $input-lock.protect: {
        $inputfh.seek($page-num * PGSIZE);
        $inputfh.read(PGSIZE);
    }
}

my $c;     # a channel for communicating between processes

my $pages; # The memory-mapped mdb file
my @threads; # the promises used for each table we actually read

sub dump-from-page($p, $count) {
    my $offset = $p;
    my @bytes;
    for ^$count {
        @bytes.push: $pages[$offset++];
    }
    dump-blob(Blob.new(@bytes), $p, 16);
}

sub dump-page($p) {
    my $page-start = $p +& +^(PGSIZE - 1);
note "Dumping page containing $p ({$page-start.base(16)})" if $dbg;
    dump-from-page($page-start, PGSIZE);
}

# Hash featuretype mirrors the featuretype table in the database. We
# read it from there, and add new entries automatically when we find
# them!

my %featuretype = ( );
my %state       = ( );
my %perennial   = ( );
my %hierarchy   = ( );
my %source      = ( );

$*OUT.out-buffer = Nil if $dbg;
$*ERR.out-buffer = Nil if $dbg;
my $doparallel;
my $justlist = 0;
my $count-only = 0;


my $dbname = 'ntmap';
my $dbprefix = 'ga_';
my $tabledir = "/tmp/import-tables-$*PID";
my $commandsfile;
my %tables;
my %loadtable;
my $pg; # Database handle

sub mmap(Pointer $addr, int32 $length, int32 $prot, int32 $flags, int32 $fd, int32 $offset) returns CArray[uint8] is native {*}

sub MAIN(
          $file,          #= mdb database file to load
         :@noload,        #= don't load table
         :@load,          #= load table
         :$db,            #= database to update
         :$prefix,        #= prefix to prepend to table names in database
         :$debug=0,       #= print (very verbose) debugging information
         :$parallel=True, #= read tables in parallel
         :$list=False,    #= just list table names
         :$count=False,   #= count number of rows in each table
        ) {
 
# Workarounds for MAIN handling bug in rakudo
    $file     = $file[0]     if $file     ~~ Positional;
    $db       = $db[0]       if $db       ~~ Positional;
    $prefix   = $prefix[0]   if $prefix   ~~ Positional;
    $debug    = $debug[0]    if $debug    ~~ Positional;
    $parallel = $parallel[0] if $parallel ~~ Positional;
    $list     = $list[0]     if $list     ~~ Positional;
    $count    = $count[0]    if $count    ~~ Positional;

    $dbname   = $db          if $db.defined;
    $dbprefix = $prefix      if $prefix.defined;
    $dbg = $debug;
    $doparallel = so $parallel;
    $justlist = $list;
    $count-only = $count;

    note "Database: $dbname";
    note "Debug: {$debug??'Yes'!!'No'}";
    note "File: $file";
    note "Prefix: $dbprefix";
    note "Parallel: {$doparallel??'Yes'!!'No'}";
    note "List: {$list??'Yes'!!'No'}";
    
    unless $justlist {
      mkdir $tabledir;
      $commandsfile = "$tabledir/commands".IO.open(:w, :append, :0out-buffer);
      $commandsfile.out-buffer = 0;
# read database table definitions
      note "Updating database $db";
      $pg = DB::Pg.new(conninfo => "dbname=$dbname");
      my $results = $pg.query("SELECT dbtable, dbcolumn, type, sourcecolumn FROM def250k WHERE source = 'data'");
      for $results.hashes -> %row {
          my $table  = %row<dbtable>;
          my $column = %row<dbcolumn>;
          my $type   = %row<type>;
          my $source = %row<sourcecolumn>;
          my $target = %row<dbcolumn>;
          %tables{$table}{$source}<type>   = $type;
	  %tables{$table}{$source}<target> = $target;
          %tables{$table}{$target}<source> = $source;
          %loadtable{$table} = 1; # by default, load all tables we know about.
      }
      $pg.finish;

    if +@load {
        %loadtable = @load Z=> 1 xx *; # overwrites initial value
    }
    if +@noload {
        for @noload { %loadtable{$_} = 0};
    }

# Read in the featuretype table
      {
	  my $result = $pg.query("SELECT name, type FROM {$dbprefix}FeatureType");
	  for $result.hashes -> $entry {
	      %featuretype{$entry<name>} = $entry<type>;
	  }
	  $pg.finish;
      }

# Read in the source table
      {
	  my $result = $pg.query("SELECT name, source FROM {$dbprefix}Source");
	  for $result.hashes -> $entry {
	      %source{$entry<name>} = $entry<source>;
	  }
	  $pg.finish;
      }

    } # $justlist
    note "Opening $file" if $dbg;
    $inputfh = $file.IO.open(:bin) or fail "Could not open $file\n";
    my $file-length = $file.IO.s;
    
    $pages = mmap(Pointer, $file-length, 1, 1, $inputfh.native-descriptor, 0); # FIX
    
    $c = Channel.new;

    read-table 2, ''; # read the top-level table, which will recursively read other tables
    # at this stage there should be lots of threads running, one for each table we want
    # wait for them all to finish

    return unless $doparallel;
    return if $justlist;

    dd @threads if $dbg;
    say "{+@threads} threads";
    await Promise.allof: @threads;
    dd @threads if $dbg;
    say "{+@threads} threads";
    note "Completed all tables";
}

my %outputfile;

sub get-fh($table) {
    if ! %outputfile<$table>.exists {
        %outputfile<$table> = "$table.sql".IO.open(:w);
    }
    %outputfile<$table>;
}

my $mess = '';

sub read-rshort($offset)
{
  my $ret = ($pages[$offset] +& 0xff) +| (($pages[$offset + 1] +& 0xff) +< 8);
#  note "read-rshort from {$offset.base(16)}: $ret ({$ret.base(16)})" if $dbg;
  $ret;
}

sub read-sshort($offset)
{
  my $ret;
  
  $ret = ($pages[$offset] +& 0xff) +| (($pages[$offset + 1] +& 0xff) +<8);
#  note "read-sshort from {$offset.base(16)}: $ret ({$ret.base(16)})" if $dbg;
  $ret +& 0x8000 ?? $ret - 65536 !! $ret;
}

sub read-rint($offset)
{
note "read-rint at {$offset.base(16)}" if $dbg;
  my $ret = 
  ($pages[$offset] +& 0xff)
    +| (($pages[$offset + 1] +& 0xff) +<  8)
    +| (($pages[$offset + 2] +& 0xff) +< 16)
    +| (($pages[$offset + 3] +& 0xff) +< 24);
#  note "read-rint @ {$offset.base(16)}: $ret ({$ret.base(16)})" if $dbg;
  $ret;
}

sub find-lval($pointer) {
note "find-lval {$pointer.base(16)}" if $dbg;
    my $ptr;
    my $length;
    my $page = $pointer +> 8;
    my $row  = $pointer +& 0xff;
  
    my $p = $page * PGSIZE;
  
    $ptr = $p + read-rshort($p+14 + $row*2);
    if $row == 0 {
      $length = ($p + PGSIZE) - $ptr;
    } else {
        my $start = read-rshort($p+14 + $row*2);
        my $end   = read-rshort($p + 14 + ($row - 1)*2);
	#$length = (read-rshort($p+14 + ($row-1) * 2) +& 0x3fff) - ($ptr +& 0x3fff);
        $length = $end - $start;
note "find-lval: start = {$start.base(16)}, $end = {$end.base(16)}, length = {$length.base(16)}" if $dbg;
    }
note "find-lval returning \"{$ptr.base(16)}, $length\"" if $dbg;
    my $x = 0;
    ($ptr, $length);
}

multi sub get-rbytes(Str $s, $count) {
    note "get-rbytes(string): {$count} bytes from {$s}" if $dbg;
#    my $buffer = $s.encode: :enc='latin1';
#    for ^$count -> $i {
#    }
     $s.encode: :enc='latin1';
}

multi sub get-rbytes(Int $p is copy, $count is copy) {
    note "get-rbytes(int): {$count} bytes from {$p.base(16)}" if $dbg;
    my @array;
    while $count-- {
        @array.push: $pages[$p++];
    }
    Blob.new(@array);
}

multi sub get-rbytes($page, $p is copy, $count is copy) {
    note "get-rbytes(int): {$count} bytes from current page: {$p.base(16)}" if $dbg;
    my @array;
    while $count-- {
        @array.push: $page[$p++];
    }
    Blob.new(@array);
}

multi sub get-rbytes(Buf $p is copy, $count is copy) {
    note "get-rbytes(int): {$count} bytes from {$p.base(16)}" if $dbg;
    $p.subbuf: 0, $count;
}

sub read-rbyte($offset) {
    $pages[$offset] +& 0xff;
}

sub read-byte($page, $offset) {
  my $ret = $pages[$page * PGSIZE + $offset] +& 0xff;
#  note "Read byte {$ret.base(16)} from page $page, offset $offset";
  $ret;
}

sub read-short($page, $offset) {
  read-rshort($page * PGSIZE + $offset);
}

sub read-int($page, $offset) {
  read-rint($page * PGSIZE + $offset);
}

sub read-rfloat($p) {
    my $buffer = Blob.new($pages[$p],
			  $pages[$p + 1],
			  $pages[$p + 2],
			  $pages[$p + 3]
	);
    $buffer.read-num32(0, LittleEndian);
}

sub read-rdouble($p) {
    my $buffer = Blob.new($pages[$p],
			  $pages[$p + 1],
			  $pages[$p + 2],
			  $pages[$p + 3],
			  $pages[$p + 4],
			  $pages[$p + 5],
			  $pages[$p + 6],
			  $pages[$p + 7]
	);
    $buffer.read-num64(0, LittleEndian);
}

sub read-long-page($pointer is copy) {
note "Read-long-page: {$pointer.base(16)}" if $dbg;
    my @bytes;
    my $length = 0;

    while $pointer {
      my $p = ($pointer +> 8) * PGSIZE;
      my $offset = read-rshort($p + 14);
      $pointer = read-rint($p+$offset); $offset += 4;
      my $nlength = PGSIZE - $offset;
      $length += $nlength;
      while $nlength-- {
	  @bytes.push: $pages[$p + $offset++] +& 0xff;
      }
    }
    (Buf.new(@bytes), $length);
}

#`[
  print-shape analyses the structure pointed to by its argument:

  At that position and a length. The structure at that position is...

  offset type purpose
    0    int  count of points (ignored)
    4    double X-min
   12    double Y-min
   20    double X-max
   24    double Y-max
   32    int    number of segments
   36    int    count
   40    int    segment offsets (array)
   40_segcount*4
         double X
         double Y
   ...
]

sub print-shape($pointer) {
    my $bb;
    my $shape;
    my @segments;
    my @segoffset;
    my $segno = -1; # Will be incremented before first access
    
    note "print-shape {$pointer.base(16)}" if $dbg;
    my ($ptr, $length) = |find-lval($pointer);
    my $count = read-rint($ptr);
    $ptr += 4;
    $*ERR.printf: "%d points, Bounding Box: ", $count if $dbg;
    my $xmin = read-rdouble($ptr);
    my $ymin = read-rdouble($ptr+8);
    my $xmax = read-rdouble($ptr+16);
    my $ymax = read-rdouble($ptr+24);
    $ptr += 32;
    $*ERR.printf: "(%g,%g) to (%g,%g)\n", $xmin, $ymin, $xmax, $ymax if $dbg;
    $bb = sprintf "((%.9g,%.9g) (%.9g,%.9g))", $xmin, $ymin, $xmax, $ymax;
    my $segments = read-rint($ptr);    $ptr += 4;
    $count       = read-rint($ptr);    $ptr += 4;
    for ^$segments { # Read segment offsets
        @segoffset[++$segno] = read-rint($ptr); $ptr += 4; # read-rint($ptr+4) ???
    }
    @segoffset[++$segno] = 2**31;
    $segno = -1;
    $*ERR.printf: "%d segments, %d points, 1st segment at point %d ", $segments, $count, @segoffset[0] if $dbg;
    for ^$count -> $point {
        if $point == @segoffset[$segno+1] {
            ++$segno;
            note sprintf "Segment %d: ", $segno if $dbg;
        }
        my $x = read-rdouble($ptr);
        my $y = read-rdouble($ptr+8);
        @segments[$segno].push: "$x $y";
        $ptr += 16;
    }
    dd @segments if $dbg;
    $shape = "SRID=4326;MULTILINESTRING((" ~
    (@segments>>.join(",")).join("),(") ~
    "))";
    ($bb, $shape);
}

sub print-shape2(Buf $p) {
    my $offset = 0;
    my $bb;
    my $shape;
    
    dd $p if $dbg;
    my $count = $p.read-int32($offset, LittleEndian);
    $offset += 4;
    $*ERR.printf: "%d points, Bounding Box: ", $count if $dbg;
    my $xmin = $p.read-num64($offset,    LittleEndian);
    my $ymin = $p.read-num64($offset+8,  LittleEndian);
    my $xmax = $p.read-num64($offset+16, LittleEndian);
    my $ymax = $p.read-num64($offset+24, LittleEndian);
    $offset += 32;
    $*ERR.printf: "(%g,%g) to (%g,%g) ", $xmin, $ymin, $xmax, $ymax if $dbg;
    $bb = sprintf "((%.5g,%.5g),(%.5g,%.5g))", $xmin, $ymin, $xmax, $ymax;
    my $segments = $p.read-int32($offset, LittleEndian);
    $offset += 4;
    $count = $p.read-int32($offset, LittleEndian);
    my $segstart = $p.read-int32($offset+4, LittleEndian);
    $offset += 8;
    $*ERR.printf: "%d segments, %d points, 1st segment at point %d ", $segments, $count, $segstart if $dbg;
    my $segptr = $offset + $segments * 4 - 4; # where the actual points start
    my $segment = 0;
    for ^$count -> $point {
	if $point == $segstart {
	    ++$segment;
	    if $segment < $segments {
	        $segstart = $p.read-int32($offset, LittleEndian);
	        $offset += 4;
	    }
	}
        my $x = $p.read-num64($segptr,   LittleEndian);
        my $y = $p.read-num64($segptr+8, LittleEndian);
        # TODO: add point to shape
	$segptr += 16;
    }
    ($bb, $shape);
}

class Column {
  has $.number  is rw;
  has $.type    is rw;
  has $.bitmask is rw;
  has $.offset  is rw;
  has $.length  is rw;
  has $.name    is rw;
}

class Table {
  has $.next             is rw; # linked list
  has $.page;                   # page this table was defined on
  has $.type             is rw;
  has $.num-columns      is rw;
  has $.num-var-columns  is rw;
  has $.usage-bitmask    is rw;
  has $.num-rows         is rw;
  has $.auto-number      is rw;
  has @.columns          is rw;
}

# void read_table(unsigned int id);

sub read-row($page is copy, $number is copy, $table) {
    my $p = 0;       # pointer into page
    my %row;
    note "read-row: $p $number $table" if $dbg;
    my $nullflags = 0;
    my $end;
    my $table-name;
    
    note "read-row:" if $dbg;
    my $offset = $page.read-uint16(14 + $number*2, LittleEndian);
    if ($offset +& 0xc000) == 0xc000 {
        note "Deleted object" if $dbg;
        return;
    }
    if $offset +& 0x4000 {
        $*ERR.printf: "Row redirect %4.4x\n", $offset +& 0x0fff;
        $*ERR.printf: "Row redirect %4.4x\n", $offset +& 0x0fff if $dbg;
        my $indirect = $page.read-uint32($offset +& 0x0fff, LittleEndian);
        $number = $indirect +& 0xff;
        my $p   = $indirect +> 8;
        $page = read-page($p);
        $*ERR.printf: "Redirecting to page %d (%x), number %d\n", $p, $p, $number if $dbg;
        $offset = $page.read-uint16(14 + $number * 2, LittleEndian);
    }
    if $number {
        $end = $page.read-uint16(14 + ($number - 1) * 2, LittleEndian) - 1;
    } else {
        $end = PGSIZE - 1;
    }
    $*ERR.printf: "  Row: start %x, end %x\n", $offset, $end if $dbg;
    $offset +&= 0x0fff;
    $end    +&= 0x0fff;
    $*ERR.printf: "Row: start %x, end %x\n", $offset, $end if $dbg;
    my $r = $offset; # offset into page
    $*ERR.printf("Row position: %x\n", $r) if $dbg;
    my $j = $table.num-columns;
    while $j > 0 {
        $nullflags +<= 8;
        $nullflags +|= $page.read-uint8($end--);
        $j -= 8;
    }
    $*ERR.printf: "Nullflags: %8.8x\n", $nullflags if $dbg;
    
    # fix offsets and lengths for variable objects */
    my $num-var-cols = $page.read-uint16($end-1, LittleEndian);
    $end -= 2;
    $*ERR.printf: "%d variable columns\n", $num-var-cols if $dbg;
    for ^$table.num-columns -> $j {
        dd %row if $dbg;
        my $column = $table.columns[$j];
        if not $column.bitmask +& 1 {
            $column.offset = $page.read-uint16($end-1, LittleEndian) - 2; # WHY -2 ?
            $*ERR.printf: "Read offset as %x from %x\n", $column.offset, ($end - 1) if $dbg;
            $end -= 2;
        }
    }
    $end = ($page.read-uint16($end - 1, LittleEndian) +& 0x0fff) - 2; # WHY -2 ?
    $*ERR.printf: "Read end as %x\n", $end if $dbg;
    for 1 .. $table.num-columns -> $j {
        my $column = $table.columns[* - $j];
        if not $column.bitmask +& 1 {
            $column.length = $end - $column.offset;
            $*ERR.printf: "VAR: offset %x, length %x\n", $column.offset, $column.length if $dbg;
            $end = $column.offset +& 0x0fff;
        }
    }
    
    my $table-id = 0;
    for ^$table.num-columns -> $j {
        my $column = $table.columns[$j];
        my $nullq = $nullflags +& 1;
        $nullflags +>= 1;
        if $column.bitmask +& 1 {
            $*ERR.printf: "fixed " if $dbg;
            if $nullq {
	        $*ERR.printf: "type %d ", $column.type if $dbg;
	        given $column.type {
	            when 1 { # boolean
		        %row{$column.name.lc} = $nullq ?? 'true' !! 'false';
	            }
	            when 2 { # byte
		        my $ivalue = $page.read-uint8($r+$column.offset + 2, LittleEndian);
		        %row{$column.name.lc} = $ivalue;
	            }
	            when 3 { # short
		        my $ivalue = $page.read-int16($r+$column.offset + 2, LittleEndian);
		        %row{$column.name.lc} = $ivalue;
	            }
	            when 4 { # int
		        my $ivalue = $page.read-uint32($r+$column.offset + 2, LittleEndian);
		        note sprintf "Reading int value: %d %8.8x", $ivalue, $ivalue if $dbg;
		        %row{$column.name.lc} = $ivalue;
		        if $column.name eq 'Id' {
		            note "Table Id $ivalue" if $dbg;
		            if $ivalue < 0x1000000 && $ivalue >= 15 {
			        $table-id = $ivalue;
			        $*ERR.printf: "Looking through table %d next\n", $table-id if $dbg;
		            }
		        }
		        dd %row if $dbg;
	            }
	            when 5 { # money
		        %row{$column.name.lc} = get-rbytes($page,$r+$column.offset + 2, 8);
	            }
	            when 6 { # float
		        my $fvalue = $page.read-num32($r+$column.offset + 2, LittleEndian);
		        %row{$column.name.lc} = $fvalue;
	            }
	            when 7 { # double
		        my $fvalue = $page.read-num64($r+$column.offset + 2, LittleEndian);
		        %row{$column.name.lc} = $fvalue;
	            }
	            when 8 { # date/time
		        my $fvalue = $page.read-num64($r+$column.offset + 2, LittleEndian);
		        $fvalue -= 25569;
		        $fvalue *= 86400;
		        my $tvalue = $fvalue;
		        %row{$column.name.lc} = "{~DateTime.new($tvalue)}";
	            }
	            default {
		        $*ERR.printf: "unknown type %2.2x\n", $column.type if $dbg;
	            }
	        }
            } else {
            }
        } else {
            $*ERR.printf: "variable " if $dbg;
            if $nullq {
	        # 	      int count;
	        # 	      unsigned char *voffset;
	        given $column.type {
	            when 10 { # text
		        my $count = $column.length / 2;
		        my $string = '';
		        my $voffset = $r + $column.offset + 2;
		        while $count-- {
		            $string ~= $page.read-uint8($voffset).chr;
		            $voffset += 2;
		        }
		        $*ERR.printf: "column name: %s, value: %s\n", $column.name, $string if $dbg;
		        %row{$column.name.lc} = $string;
		        if $column.name eq 'Name' {
		            $table-name = "E'{$string}";
		        }
	            }
	            when 11 { # OLE
		        my $voffset = $r + $column.offset + 2;
		        $*ERR.printf: "voffset = %x\n", $voffset if $dbg;
		        my $length = $page.read-uint16($voffset, LittleEndian);
		        $*ERR.printf: "length: %d\n", $length if $dbg;
		        my $bitmask = $page.read-uint16($voffset+2, LittleEndian);
		        $*ERR.printf: "bitmask: %x\n", $bitmask if $dbg;
		        my $pointer = $page.read-uint32($voffset+4, LittleEndian);
		        $*ERR.printf: "OLE: pointer %x\n", $pointer if $dbg;
		        if $bitmask +& 0x8000 {
		            note "0x8000" if $dbg;
		            # data is here
		            $voffset += 12;
		            if 'shape' eq $column.name.lc {
			        my $count = $page.read-uint32($voffset, LittleEndian);
			        note "Got shape; count is $count" if $dbg;
			        if $count == 1 {
			            %row{$column.name.lc} = "SRID=4326;POINT({read-rdouble($voffset+4)} {$page.read-num64($voffset+12, LittleEndian)})";
			        } else {
			            my $offset = $voffset+4;
			            my @points;
			            while $count-- {
				        my $lat = $page.read-num64($offset, LittleEndian);
				        my $long = $page.read-num64($offset+8, LittleEndian);
				        @points.push: "$long $lat";
				        note "Adding point $long $lat" if $dbg;
				        $offset += 8;
			            }
			            %row<shape> = "SRID=4326;MULTILINESTRING(" ~ @points.join(',') ~ ')';
		                }
		            } else {
                                note "Unknown OLE column {$column.name}" if $dbg;
			        %row{$column.name.lc} = get-rbytes($page, $voffset, $length);
		            }
		        } elsif $bitmask +& 0x4000 {
		            note "0x4000 Column {$column.name}" if $dbg;
		            if $column.name eq 'SHAPE' {
			        my ($bb, $shape) = |print-shape($pointer);
			        %row{$column.name.lc} = $shape;
		            } else {
			        $*ERR.printf: "pointer %x\n", $pointer if $dbg;
			        my ($ptr, $length) = |find-lval($pointer);
			        %row{$column.name.lc} = get-rbytes($page, $ptr, $length);
			        note "Finished" if $dbg;
		            }
		        } else {
		            note "0x4000 not set: column name {$column.name}" if $dbg;
		            my ($str, $length) = |read-long-page($pointer);
		            dd $str if $dbg;
		            if $column.name eq 'SHAPE' {
			        my ($bb, $shape) = print-shape2($str);
			        %row{$column.name.lc} = $shape;
		            } else {
			        %row{$column.name.lc} = get-rbytes($str, $length);
		            }
		        }
	            }
	            default {
		        note "Default case for OLE" if $dbg;
                        #			put-rbytes($r+$column.offset + 2, $column.length);
	            }
	        }
            } else {
	        %row{$column.name.lc} = '(null)';
            }
        }
        $*ERR.printf: "\n" if $dbg;
    }
    
    # We've found a pointer to a table; should we read it?
    if $table-id {
        note "Found table {%row<name>}" if $dbg;
        if $justlist {
            say %row<name>;
        } else {
            if %tables{%row<name>}.defined && %loadtable{%row<name>}.defined && %loadtable{%row<name>} {
                %loadtable{%row<name>} = 0; # we're seeing some tables multiple times -- why?
                if $doparallel {
                    @threads.push: start { read-table($table-id, %row<name>) }
                } else {
                    read-table($table-id, %row<name>);
                }
            }
        }
    }
    note "Returning from read-row" if $dbg;
    dd %row if $dbg;
    %row;
}

my %tableptr;

sub process-data-page($page, $table, $table-type, $output, @columns, $table-name) {
    note "process-data-page:" if $dbg;
    $*ERR.printf: "Free space: %4.4x\n", $page.read-uint16(2, LittleEndian) if $dbg;
    my $tablep = $page.read-uint32(4, LittleEndian);

    fail 'Found unexpected LVAL page' if $tablep == 0x4c41564c; # 'LVAL'
    
    $*ERR.printf: "Table Description pointer: %s\n", $tablep.base(16) if $dbg;
    
    if $table {
        note "Found table definition" if $dbg;
    } else {
        note "No table definition found" if $dbg;
        return;
    }
    
    $*ERR.printf: "Unknown: %8.8x\n", $page.read-uint32(8, LittleEndian) if $dbg;
    my $numrec = $page.read-uint16(12, LittleEndian);
    $*ERR.printf: "%d records in this page", $numrec if $dbg;
    my @row = (PGSIZE,);
    my $ptr = 14;
    for ^$numrec -> $i {
        my $roffset = $page.read-uint16($ptr, LittleEndian);     $ptr += 2;
        $*ERR.printf: "    %4.4x\n", $roffset if $dbg;
        @row.push: $roffset;
    }
    dd @row if $dbg;
    
    # Now try to interpret the rows
    for ^$numrec -> $i {
        my %row = read-row($page, $i, $table);
        do-insert(%row, $output, @columns, $table-name);
    }
    note "End process-data-page" if $dbg;
}

# Runs simultaneously in multiple threads

sub read-table-header($page) {
    note "Table definition ($page)\n" if $dbg;
    my $table = Table.new(:$page);
    %tableptr{$page} := $table; # ALSO DANGEROUS -- FIX (might not actually be necessary; we read this for each page, and it won't be used elsewhere!)
    dd $table if $dbg;
    my $ptr = 1;
    note "unknown: {read-byte($page, $ptr).base(16)}"       if $dbg; $ptr++;
    note "Free space - 8: {read-short($page, $ptr).base(16)}"      if $dbg; $ptr += 2;
    note "next page: {read-int($page, $ptr).base(16)}"      if $dbg; $ptr += 4;
    note "length of data: {read-int($page, $ptr).base(16)}" if $dbg; $ptr += 4;
    note "unknown: {read-int($page, $ptr).base(16)}"        if $dbg;   $ptr += 4;
    $table.num-rows = read-int($page, $ptr); $ptr += 4;
    note "{$table.num-rows} records" if $dbg;
    $table.auto-number = read-int($page, $ptr); $ptr += 4;
    note "next autonumber value: {$table.auto-number}" if $dbg;
    note "auto-number flag: {read-int($page, $ptr).base(16)}"         if $dbg; $ptr += 4;
    note "autonumber for complex columns: {read-int($page, $ptr).base(16)}"         if $dbg; $ptr += 4;
    note "unknown: {read-int($page, $ptr).base(16)}"         if $dbg; $ptr += 4;
    note "unknown: {read-int($page, $ptr).base(16)}"         if $dbg; $ptr += 4;
    $table.type = read-byte($page, $ptr++);
    note "table type: {$table.type.base(16)}"                      if $dbg;
    note "max columns: {read-short($page, $ptr)}"            if $dbg; $ptr += 2;
    $table.num-var-columns = read-short($page, $ptr);                      $ptr += 2;
    note "number of variable columns: {$table.num-var-columns}" if $dbg;
    $table.num-columns = read-short($page, $ptr);                                $ptr += 2;
    note "number of columns: {$table.num-columns}"           if $dbg;
    note "{read-int($page, $ptr)} indexes"                   if $dbg; $ptr += 4;
    my $num-real-index = read-int($page, $ptr);                                  $ptr += 4;
    note "{$num-real-index} index entries"                    if $dbg;
    $table.usage-bitmask = read-int($page, $ptr);                                $ptr += 4;
    note "Usage bitmask: {$table.usage-bitmask.base(16)}"          if $dbg;
    note "Free pages: {read-int($page, $ptr).base(16)}"            if $dbg; $ptr+= 4;
    
    for ^$num-real-index -> $i {
        note "index {$i+1}"                              if $dbg;
        note "unknown {read-int($page, $ptr).base(16)}"  if $dbg; $ptr += 4;
        note "{read-int($page, $ptr)} index rows"        if $dbg; $ptr += 4;
        note "unknown {read-int($page, $ptr)}"           if $dbg; $ptr += 4;
    }
    
    my $columns;
    for ^$table.num-columns -> $i {
        note "column {$i+1}" if $dbg;
        $columns[$i] = Column.new(type => read-byte($page, $ptr++));
        $*ERR.printf("    column type %2.2x (", $columns[$i].type) if $dbg;
        if $dbg {
            given $columns[$i].type {
                when  1 { note "boolean)"             }
                when  2 { note "byte)"                }
                when  3 { note "short)"               }
                when  4 { note "int)"                 }
                when  5 { note "currency)"            }
                when  6 { note "float)"               }
                when  7 { note "double)"              }
                when  8 { note "short date/time)"     }
                when  9 { note "binary -- 255 bytes)" }
                when 10 { note "text -- 255 bytes)"   }
                when 11 { note "OLE)"                 }
                when 12 { note "memo)"                }
                when 15 { note "GUID)"                }
                default { note "unknown)"             }
            }
        }
        $*ERR.printf("    unknown %8.8x\n", read-int($page, $ptr))        if $dbg; $ptr += 4;
        $columns[$i].number = read-short($page, $ptr);                               $ptr += 2;
        $*ERR.printf("    column number %d\n", $columns[$i].number)       if $dbg;
        $columns[$i].offset = read-short($page, $ptr);                               $ptr += 2;
        $*ERR.printf("    variable offset: %4.4x\n", $columns[$i].offset) if $dbg;
        $*ERR.printf("    column number %d\n", read-short($page, $ptr))   if $dbg; $ptr += 2;
        $*ERR.printf("    unknown %8.8x\n",    read-int($page, $ptr))     if $dbg; $ptr += 4;
        $columns[$i].bitmask = read-byte($page, $ptr++);
        $*ERR.printf("    bitmask: %2.2x\n", $columns[$i].bitmask)        if $dbg;
        $*ERR.printf("    misc_flags: %2.2x\n", read-byte($page, $ptr))   if $dbg; $ptr++;
        $*ERR.printf("    unknown %8.8x\n", read-int($page, $ptr))        if $dbg; $ptr += 4;
        $columns[$i].offset = read-short($page, $ptr);                               $ptr += 2;
        $*ERR.printf("    fixed offset: %4.4x\n", $columns[$i].offset)    if $dbg;
        $columns[$i].length = read-short($page, $ptr);                               $ptr += 2;
        $*ERR.printf("    column length: %d\n", $columns[$i].length)      if $dbg;
    }
    for ^$table.num-columns -> $i {
        my $c;
        my $namep;
        
        # Read a little-endian UCS-2 encoded string
        my $len = read-short($page, $ptr); $ptr += 2;
        $*ERR.printf: "   Column %d (%d) label (%d chars): \"",
        $i, $columns[$i].number, $len/2 if $dbg;
        my $name;
        while $len > 0 {
            my $c = read-short($page, $ptr); $ptr += 2;
            $len -= 2;
            $name ~= $c.chr;
        }
        $*ERR.printf("$name\"\n") if $dbg;
        $columns[$i].name = $name;
        #       $columns[$i].name = $pages.subbuf($page * PGSIZE + $ptr, $len * 2).decode: :encoding => 'utf16'; # Still wrong -- $pages is a CARRAY
        for ^$table.num-columns -> $i {
            $table.columns[$columns[$i].number] = $columns[$i];
        }
    } 
    for ^$num-real-index -> $i {
        $*ERR.printf("  index %d: %8.8x\n", $i+1, read-int($page, $ptr)) if $dbg;
        $ptr += 4;
    }
    $table;
}

sub read-bits($p, $length, $page is rw, @pgs) {
    note "read-bits: $p $length $pg" if $dbg;
    for ^$length -> $i {
        my $x = $pages[$p + $i];
        if $x {
            for ^8 {
	        if $x +& 1 {
                    @pgs.push: $page;
		    $*ERR.printf("%d ", $page) if $dbg;
		}
	        $page++;
	        $x +>= 1;
	    }
	} else {
	    $page += 8;
	}
    }
}

sub read-bitmask($ptr) {
    my $page-offset = 0;
    my $bytes;
    my $end;
    my @pgs;
    
    $*ERR.printf("read-bitmask: %x\n", $ptr) if $dbg;
    my $entry = $ptr +& 0xff;
    my $p = ($ptr +> 8) * PGSIZE + 14 + ($entry * 2);
    my $offset = read-rshort($p);
    if $entry == 0 {
        $bytes = PGSIZE - $offset - 5;
        note "Entry is 0, offset $offset" if $dbg;
    } else {
        $end = read-rshort($p - 2);
        note "Entry is 1, end: $end, offset: $offset" if $dbg;
        $bytes = $end - $offset - 5;
    }
    $*ERR.printf("read-bitmask: offset %04.4x, length %d\n", $offset, $bytes + 5) if $dbg;
    $p = ($ptr +> 8) * PGSIZE + $offset;
    dump-from-page($p, $bytes + 5) if $dbg;
    if $pages[$p] == 0x00 {
        note "bitmap type 0" if $dbg;
        ++$p;
        $page-offset = read-rint($p);
        $p += 4;
        read-bits($p, $bytes, $page-offset, @pgs);
    } elsif $pages[$p] == 0x01 {
        note "bitmap type 1 ($bytes)" if $dbg;
        $p++;
        $bytes += 4;
        while $bytes > 3 {
            note "Reading bitmask pages" if $dbg;
            my $next-page = read-rint($p);
            note "read page {$next-page.base(16)}" if $dbg;
            $next-page *= PGSIZE;
            note "read-bitmask: read page {$next-page.base(16)}" if $dbg;
            if $next-page {
                dump-page($next-page) if $dbg;
note "bitmask page {$next-page.base(16)}, page-offset: $page-offset" if $dbg;
                my $magic = read-rshort($next-page);
                note "Incorrect bitmask page $p ({$magic.base(16)})" unless $magic == 0x0105;
                read-bits $next-page + 4, 4092, $page-offset, @pgs; # Fix for Jet 3
            } else {
              $page-offset += 4092 * 8;
            }
            $bytes -= 4;
            $p += 4;
        }
    } else {
        $*ERR.printf: "Unknown bit map page type %d\n", $pages[$p] if $dbg;
        exit(3);
    }
    my $count = 0;
    note "Reading bitmap ($bytes bytes) from position {$p.base(16)}" if $dbg;
    note "{+@pgs} pages of data";
    dd @pgs if $dbg;
    @pgs;
}

sub read-data-page($id, $table, $table-type, $output, @columns, $table-name) {
  note "read-data-page:" if $dbg;
  $*ERR.printf: "read-data-page: reading page %d (%x)\n", $id, $id if $dbg;
  my $page = read-page($id);
  my $type = $page.read-uint16(0, LittleEndian);
  $*ERR.printf: "read-data-page: type %d\n", $type if $dbg;
  if $type != 0x0101 {
      fail "Pointer to data page ($id) does not point to data page";
  }
  process-data-page($page, $table, $table-type, $output, @columns, $table-name);
  note "end read-data-page" if $dbg
}

sub print-data-pages($p) {
#  $*ERR.printf: "Remaining data pages:" if $dbg;
#  while (*p)
#    {
#      if(dbg)printf(" %d", *p);
#      ++p;
#    }
#  if(dbg)printf("\n");
}

# read-table is called in multiple threads -- it should alter nothing global

sub read-table($id is copy, $name is copy) {
return unless !$name or $name ne 'Bores';
    #my $dbg = 1;
    my @columns;
    note "read-table ($name)";
    note "read-table ($name):" if $dbg;
    my $output;
    my $columns;
    my $file = $tabledir ~ '/' ~ $name ~ '.sql';
    if $name {
	dd %tables{$name} if $dbg;
	for %tables{$name}.keys.sort -> $column {
            note "column $column:" if $dbg;
            dd %tables{$name}{$column} if $dbg;
            if %tables{$name}{$column}<source>.defined {
		note "Pushing column $column" if $dbg;
#		@columns.push: %tables{$name}{$column}<target>;
		@columns.push: $column;
	    }
            dd @columns if $dbg;
	}
	dd @columns if $dbg;
	$columns = @columns.join: ', ';
        $output = $file.IO.open(:a, out-buffer => False);
        dd $output if $dbg;
    } else {
	note "No database connection for $name";
    }
    my $table-type = %tables{$name};
    dd $table-type if $dbg;
    $*ERR.printf: "Reading table on page %d (%x)\n", $id, $id if $dbg;
    note "Calling read-table-header" if $dbg;
    my $table = read-table-header($id);
    note "Back from read-table-header" if $dbg;
    if $name && $count-only {
        say "$name: {$table.num-rows}";
        return;
    }
    dd $table if $dbg;
    $*ERR.printf: "table bitmask: %x\n", $table.usage-bitmask if $dbg;
    my @pgs = read-bitmask($table.usage-bitmask);
#    dd @pgs if $dbg;
    for @pgs -> $pp {
	note "Reading $name data page $pp" if $dbg;
	print-data-pages($pp) if $dbg;
	$*ERR.printf("Data page %d\n", $pp) if $dbg;
	read-data-page($pp, $table, $table-type, $output, @columns, $name);
    }
    note "No more data pages" if $dbg;
    if $output {
        $output.close;
        my $copycmd = "copy {$dbprefix ~ $name} ($columns) from '$file';";
	note $copycmd;
        $commandsfile.put: $copycmd ~ "\n";
	$pg.query: $copycmd;
    }
    # $output.unlink;
    note "end read-table \"$name\"";
    1;
}

#################################
#
# Now the code for processing the data and writing the database files
#
#################################


#$dbg = 1;
my @row;

sub get-featuretype($name, $prefix) {
    note "get-featuretype($name, $prefix)" if $dbg;
    return %featuretype{$name} if defined %featuretype{$name};
    note "new entry required" if $dbg;
    $name ~~ s:g/\'/\\'/;
    my $result = $pg.query("INSERT INTO {$prefix}FeatureType (name)
                                 VALUES (\$1)
                            ON CONFLICT DO NOTHING
                              RETURNING type
                           ", $name).value;
### FIX
    dd $result if $dbg;
    my $type = $result;
    %featuretype{$name} = $type;
    $*ERR.say: "Added featuretype $type ($name) to database\n" if $dbg;
    $type;
}


sub get-state($name, $prefix) {
    note "get-state($name, $prefix)" if $dbg;
    return %state{$name} if defined %state{$name};
    note "new entry required" if $dbg;
    $name ~~ s:g/\'/\\'/;
    my $result = $pg.query("INSERT INTO {$prefix}State (name)
                                 VALUES (\$1)
                            ON CONFLICT DO NOTHING
                              RETURNING state
                           ", $name).value;
### FIX
    dd $result if $dbg;
    my $type = $result;
    %state{$name} = $type;
    $*ERR.say: "Added state $type ($name) to database\n" if $dbg;
    $type;
}


sub get-perennial($name, $prefix) {
    note "get-perennial($name, $prefix)" if $dbg;
    return %perennial{$name} if defined %perennial{$name};
    note "new entry required" if $dbg;
    $name ~~ s:g/\'/\\'/;
    my $result = $pg.query("INSERT INTO {$prefix}Perennial (description)
                                 VALUES (\$1)
                            ON CONFLICT DO NOTHING
                              RETURNING perennial
                           ", $name).value;
    dd $result if $dbg;
    my $type = $result;
    %perennial{$name} = $type;
    $*ERR.say: "Added perennial type $type ($name) to database\n" if $dbg;
    $type;
}


sub get-hierarchy($name, $prefix) {
    note "get-hierarchy($name, $prefix)" if $dbg;
    return %hierarchy{$name} if defined %hierarchy{$name};
    note "new entry required" if $dbg;
    $name ~~ s:g/\'/\\'/;
    my $result = $pg.query("INSERT INTO {$prefix}Hierarchy (description)
                                 VALUES (\$1)
                            ON CONFLICT DO NOTHING
                              RETURNING hierarchy
                           ", $name).value;
    dd $result if $dbg;
    my $hierarchy = $result;
    %hierarchy{$name} = $hierarchy;
    $*ERR.say: "Added hierarchy type $hierarchy ($name) to database\n" if $dbg;
    $hierarchy;
}


sub get-source($name, $prefix) {
    note "get-source($name, $prefix)" if $dbg;
    return %source{$name} if defined %source{$name};
    note "new entry required" if $dbg;
    $name ~~ s:g/\'/\\'/;
    my $result = $pg.query("INSERT INTO {$dbprefix}Source (name)
                                 VALUES ($name)
                            ON CONFLICT DO NOTHING
                              RETURNING source
                           ", $name).value;
### FIX
    dd $result if $dbg;
    my $source = $result;
    %source{$name} = $source;
    $*ERR.say: "Added source $source ($name) to database\n" if $dbg;
    $source;
}


my $objects = 0;
my $table-name;
my %row;

sub do-insert(%row, $output, @columns, $table-name) {

    return unless $output;
    
    my @values;

    note "do-insert:" if $dbg;
    dd @columns if $dbg;
    for @columns -> $column {
    dd %tables{$table-name} if $dbg;
        my $source = %tables{$table-name}{$column.lc}<source>;
	note "Reading $column from $source" if $dbg;

        my $value;
        if %row{$source}.defined {
	    dd $source if $dbg;
	    dd $table-name if $dbg;
	    dd %tables{$table-name} if $dbg;
	    dd %tables{$table-name}{$source.lc} if $dbg;
	    dd %row{$source} if $dbg;
            $value = get-value(%row{$source}, %tables{$table-name}{$source.lc});
            note "Got $value for $column" if $dbg;
            $value ~~ s:g/\\/\\\\/;
            $value ~~ s:g/\n/\\n/;
            $value ~~ s:g/\r/\\r/;
            $value ~~ s:g/\t/\\t/;
        } else {
            $value = '\N' unless $value;
        }
        @values.push: $value;
    }
    my $values = (@values.join: "	") ~ "\n"; # That's a tab folks
    $output.print: $values;
    %row = ();
}

sub hexbyte($byte) {
    sprintf "\\%03o", $byte;
}

# Turn raw value into a string suitable for use in a copy command

sub get-value($value is copy, %def) {
    dd %def if $dbg;
    my $column = %def<target>;
#    note "get-value: $value for $column" if $dbg;
#### TODO generalise this using characteristics in def250k table
    given $column {
        when 'featuretype' {
            $value = get-featuretype($value, $dbprefix);
        }
        when 'source' {
            $value = get-source($value, $dbprefix);
        }
        when 'state' {
            $value = get-state($value, $dbprefix);
        }
        when 'perennial' {
            $value = get-perennial($value, $dbprefix);
        }
        when 'hierarchy' {
            $value = get-hierarchy($value, $dbprefix);
        }
    }

    given %def<type> {
	when 'int' | 'smallint' | 'float' {
	    $value = ~+$value;
	}
	when 'date' {
	}
	when 'timestamp' {
	}
	when 'text' {
	}
	when 'point' {
	}
	when 'line'|'area' {
	}
        when 'bytea' {
            my $str = ''; # 'E' ~ "'" ~ '\x';
	    for $value.list -> $byte {
		$str ~= hexbyte($byte);
	    }
	    $value = $str;
	}
	default {
           fail "Unknown data type %def<type>";
	}
    }
    $value;
}

sub process-data {
    my $dbh;
    my $table-type;
    my $insert-data = 0;
    for $c.list -> $line {
	given $line {
	    note $line if $dbg;
	    #Column 0 (Id): 15 0000000f
	    when /^Column \s* (\d+) \s* \( (\w+) \) \: (.*) / {
		my $columnnumber = +$0;
		my $columnname   = ~$1.lc;
		my $columnvalue  = ~$2;
		#note "do-insert into \"$table-name\"" if $columnnumber == 0 && $table-name;
		do-insert %row, $dbh if $columnnumber == 0 && $insert-data;
		next unless $table-name && %tables{$table-name}{$columnname}.defined;
		$columnvalue ~~ s/ ^ \s+   //;
		$columnvalue ~~ s/   \s+ $ //;
		next unless $columnvalue;
		$insert-data = 1;

		if $columnname eq 'feattype' {
		    $columnvalue = get-featuretype($columnvalue, $dbprefix);
		}
		if $columnname eq 'source' {
		    $columnvalue = get-source($columnvalue, $dbprefix);
		}
		if $columnname eq 'state' {
		    $columnvalue = get-state($columnvalue, $dbprefix);
		}
		if $columnname eq 'perennial' {
		    $columnvalue = get-perennial($columnvalue, $dbprefix);
		}
		if $columnname eq 'hierarchy' {
		    $columnvalue = get-hierarchy($columnvalue, $dbprefix);
		}
		given %tables{$table-name}{$columnname}<type> {
		    when 'int' | 'smallint' {
			$columnvalue ~~ / ^ \s* (\d+)/;
			if $0.defined {
			    %row{$columnname} = +$0;
			}
		    }
		    when 'featuretype' {
			my $ftype = get-featuretype($columnvalue, $dbprefix);
			%row<$columnname> = $ftype;
		    }
		    when 'source' {
			my $source = get-source($columnvalue, $dbprefix);
			%row<$columnname> = $source;
		    }
		    when 'state' {
			my $state = get-state($columnvalue, $dbprefix);
			%row<$columnname> = $state;
		    }
		    when 'perennial' {
			my $perennial = get-perennial($columnvalue, $dbprefix);
			%row<$columnname> = $perennial;
		    }
		    when 'hierarchy' {
			my $hierarchy = get-hierarchy($columnvalue, $dbprefix);
			%row<$columnname> = $hierarchy;
		    }
		    when 'date' {
			$columnvalue ~~ /^\s*(....)\-(..)\-(..).*/;
			%row{$columnname} = "'$0 $1 $2'";
		    }
		    when 'timestamp' {
			%row{$columnname} = "'" ~ $columnvalue ~ "'";
		    }
		    when 'float' {
			%row{$columnname} = +$columnvalue;
		    }
		    when 'text' {
			$columnvalue ~~ s:g/ \\ /\\\\/;
			$columnvalue ~~ s:g/ \' /\'\'/;
                        %row{$columnname} = "E'{$columnvalue}'";
                    }
            when 'point' {
                  $columnvalue ~~ /Long ' ' (\S+) ' ' Lat ' ' (.*)/;
                  my ($long, $lat) = (~$0, ~$1);
                  $long ~~ s/\,$//;
 #                %row{$columnname} = "ST_GeomFromText('POINT($long $lat)', 4326)";
                  %row{$columnname} = "SRID=4326;POINT($long $lat)";
            }
            when 'line' {
                  $columnvalue ~~ s:g/\,//;
                  $columnvalue ~~ s:g/ \) \s+ \( /, /;
                  $columnvalue ~~ s/^/(/;
                  $columnvalue ~~ s:g/ \s* Segment \s+ \d+ \: \s*/) (/;
                  $columnvalue ~~ s/^\(\) //;
                  $columnvalue ~~ s/[\,\s\(]? $//;
                  $columnvalue ~~ s:g/ \) \) \s+ \( \( /), (/;
                  $columnvalue ~~ s/^\s+//;
#                 %row<shape> = "ST_GeomFromText('MULTILINESTRING{$columnvalue}', 4326)";
                  %row<shape> = "SRID=4326;MULTILINESTRING{$columnvalue}";
            }
	    when 'geometry' {
	        $*ERR.say: "shape (type {$table-type}): {$columnvalue}" if $dbg;
	        if $table-type eq 'point' {
	          $columnvalue ~~ /Long ' ' (\S+) ' ' Lat ' ' (.*)/;
                  my ($long, $lat) = (~$0, ~$1);
                  $long ~~ s/\,$//;
                  %row{$columnname} = "ST_GeomFromText('POINT($long $lat)', 4326), ";
	        } else {
                  $columnvalue ~~ s:g/\,//;
                  $columnvalue ~~ s:g/ \) \s+ \( /, /;
                  $columnvalue ~~ s/^/(/;
                  $columnvalue ~~ s:g/ \s* Segment \s+ \d+ \: \s*/) (/;
                  $columnvalue ~~ s/^\(\) //;
                  $columnvalue ~~ s/[\,\s\(]? $//;
                  $columnvalue ~~ s:g/ \) \) \s+ \( \( /), (/;
                  $columnvalue ~~ s/^\s+//;
                  %row<shape> = "ST_GeomFromText('MULTILINESTRING{$columnvalue}', 4326)";
	        }
	    }
	    when 'bytea' {
	        $*ERR.say: "BYTEA: {$columnvalue}" if $dbg;
                my $columnvalues = '';
                $columnvalue ~~ s/^E\'//;
                $columnvalue ~~ s/\'$//;
                for $columnvalue.split: ' ' -> $byte {
                  $columnvalues ~= sprintf "\\\\%03o", :16($byte) if $byte;
                }
                %row{$columnname} = $columnvalues;
	    }
            default {
                # ignore other rows
            }
        }
      }
    }
  }
}


#!/usr/bin/perl -w

use strict;

use DBI;
use UTM;

my $symbols = 'Symbols_GA';

my $scale = 25000;
my ($lllongitude, $lllatitude);
my ($lrlongitude, $lrlatitude);
my ($ullongitude, $ullatitude);
my ($urlongitude, $urlatitude);
my ($lleasting, $llnorthing);
my ($lreasting, $lrnorthing);
my ($uleasting, $ulnorthing);
my ($ureasting, $urnorthing);
my $zone;

my @featuretype = ();
my %featuretype = ();
my @display_feature = ();
my %nofeature = ();

my %drawobjects;
my %allobjects = map {$_, 1} qw(
                  el_contour
                  hy_water_area_polygon
                  hy_water_point
                  hy_water_struct_area_polygon
                  hy_water_struct_line
                  hy_water_struct_point
                  hy_watercourse
                  lga_polygon
                  locality_polygon
                  tr_air_infra_area_polygon
                  tr_airport_infrastructure
                  tr_rail;
                  tr_rail_infrastructure
                  tr_road
                  tr_road_infrastructure
                  graticule
                  grid
                  userannotations
	       );

for my $type (keys %allobjects) {
    $drawobjects{$type} = 1; # default to drawing everything
}

my @annotations = ();

sub add_annotation {
    my ($long, $lat, $xoffset, $yoffset, $string) = @_;
    my $annotation = {};
    ${$annotation}{long} = $long;
    ${$annotation}{lat} = $lat;
    ${$annotation}{xoffset} = $xoffset;
    ${$annotation}{yoffset} = $yoffset;
    ${$annotation}{string} = $string;
    push @annotations, $annotation;
    #print STDERR "Adding annotation at $long,$lat: $string\n";
}

my %papersizes = (
    'a3' => '297,420',
    'a4' => '210,297',
    );
my $papersize = 'a3';
my ($paperwidth, $paperheight);
my $orientation = 'landscape';
my ($leftmarginwidth, $lowermarginwidth, $rightmarginwidth, $uppermarginwidth)
    = (30, 25, 30, 25); # negative to bleed over page boundary
my ($imagewidth, $imageheight);
my ($gridwidth, $graticulewidth);
my ($gridheight, $graticuleheight);
my $db = 'vicmap';
my $grid_spacing = 10000;
my $graticule_spacing = .25;
my ($ongrid, $ongraticule) = (0, 0);
my ($bleedright, $bleedtop) = (0, 0);

sub process_option {
    my $arg = shift;

#    print STDERR "Processing option $arg\n";
    if ($arg =~ /^annotation\s*=\s*(\-?[\d\.]+)[,\s]+(\-?[\d\.]+)[,\s]+(\-?[\d\.]+)[,\s]+(\-?[\d\.]+)[,\s]+(.*)/) {
	add_annotation($1, $2, $3, $4, $5);
	return;
    }
# ignore whitespace in all remaining options
    $arg =~ s/\s+//g;
    if ($arg =~ /^papersize=(.*)/) {
	$papersize = $1;
	return;
    }
    if ($arg =~/orientation=(.*)/) {
	$orientation = $1;
	return;
    }
    if ($arg =~/bleedright=(.*)/) {
	$bleedright = $1;
	$rightmarginwidth = -20;
	return;
    }
    if ($arg =~/bleedtop=(.*)/) {
	$bleedtop = $1;
	$uppermarginwidth = -10;
	return;
    }
    if ($arg =~ /^leftmarginwidth=(d+(\.\d+)?)$/) {
        $leftmarginwidth = $1;
        return;
    }
    if ($arg =~ /^rightmarginwidth=(d+(\.\d+)?)$/) {
        $rightmarginwidth = $1;
        return;
    }
    if ($arg =~ /^(lower|bottom)marginwidth=(d+(\.\d+)?)$/) {
        $lowermarginwidth = $2;
        return;
    }
    if ($arg =~ /^(upper|top)marginwidth=(d+(\.\d+)?)$/) {
        $uppermarginwidth = $2;
        return;
    }
    if ($arg =~/d(ata)?b(ase)?=(.*)/) {
	$db = $3;
	return;
    }
    if ($arg =~ /^lat(itude)?=(\-?[\d\.]+)$/i) {
	$lllatitude = $2;
	$ongraticule = 1;
	return;
    }
    if ($arg =~ /^long(itude)?=(\-?[\d\.]+)$/i) {
	$lllongitude = $2;
	$ongraticule = 1;
	return;
    }
    if ($arg =~ /^east(ing)?=(\d+)(k?)m?$/i) {
	$lleasting = $2;
	$lleasting *= 1000 if lc $3 eq 'k';
	$ongrid = 1;
        return;
    }
    if ($arg =~ /^north(ing)?=(\d+)(k?)m?$/i) {
        $llnorthing = $2;
	$llnorthing *= 1000 if lc $3 eq 'k';
	$ongrid = 1;
        return;
    }
    if ($arg =~ /^width=(\d+(\.\d+)?)([kK])?([dDmM]?)$/) {
	if (lc $4 eq 'm') {
	    $gridwidth = $1;
            $gridwidth *= 1000 if lc $3 eq 'k';
	    $ongrid = 1;
	    #print STDERR "Grid width: $gridwidth\n";
	} else {
	    $graticulewidth = $1;
	    $ongraticule = 1;
	}
        return;
    }
    if ($arg =~ /^height=(\d+(\.\d+)?)([kK])?([dDmM]?)$/) {
	if (lc $4 eq 'm') {
	    $gridheight = $1;
            $gridheight *= 1000 if lc $3 eq 'k';
	    #print STDERR "Grid height: $gridheight\n";
	    $ongrid = 1;
	} else {
	    $graticuleheight = $1;
	    $ongraticule = 1;
	}
        return;
    }
    if ($arg =~ /^zone?=(\d+[A-Z]?)$/i) {
        $zone = uc $1;
	print STDERR "Zone: $zone\n";
        return;
    }
    if ($arg =~ /^scale\=(1:)?(\d+)([kKmM]?)$/i) {
	$scale = $2;
	$scale *= 1000 if lc $3 eq 'k';
	$scale *= 1000000 if lc $3 eq 'm';
	return;
    }
    if ($arg =~ /^grid(spacing)?\=(\d+)([kK]?)m?$/i) {
	$grid_spacing = $2;
	$grid_spacing *= 1000 if lc $3 eq 'k';
	return;
    }
    if ($arg =~ /^graticule(spacing)?\=(\d+)([dDmM]?)$/i) {
	$graticule_spacing = $2;
	$graticule_spacing /= 60 unless lc $3 eq 'd';
	return;
    }
    if ($arg =~ /^display=all$/i) {
	for my $type (keys %allobjects)
	{
	    $drawobjects{$type} = 1;
	}
	return;
    }
    if ($arg =~ /^display=(\S+)$/i) {
	$drawobjects{lc $1} = 1;
	return;
    }
    if ($arg =~ /^nodisplay=all$/i) {
	%drawobjects = ();
	return;
    }
    if ($arg =~ /^nodisplay=(\S+)$/i) {
	undef $drawobjects{lc $1};
	return;
    }
    if ($arg =~ /^nofeature=(\S+)$/i)
    {
        my $ft = $1;
        $ft =~ s/_/ /g;
        $nofeature{$ft} = 1;
        #print STDERR "No feature: $ft\n";
	return;
    }
    if ($arg =~ /^symbols=(\S+)$/i) {
	$symbols = lc $1;
        return;
    }
    if ($arg =~ /^file=(.*)/i) {
	#print STDERR "Including file $1\n";
	if (open INC, "<$1") {
	    while(<INC>) {
		chomp;
		s/\#.*//;
		s/^\s+//;
		s/\s+$//;
		next unless $_;
		process_option($_);
	    }
	    close INC;
	}
	return;
    }
    print STDERR "Unknown option \"$arg\" ignored\n";
}

if (open OPT, "<$ENV{'HOME'}/.drawrc") {
    while(<OPT>) {
	chomp;
	s/\#.*//;
	s/^\s+//;
	s/\s+$//;
	next unless $_;
	process_option($_);
    }
    close OPT;
}

if (open OPT, "<.drawrc") {
    while(<OPT>) {
	chomp;
	s/\#.*//;
	s/^\s+//;
	s/\s+$//;
	next unless $_;
	process_option($_);
    }
    close OPT;
}

for my $arg (@ARGV) {
    process_option($arg);
}

# Calculate various things which depend on the options

if($ongrid && $ongraticule) {
    die "Must use either grid coordinates or lat/lon; not a mixture\n";
}

# How much space do we have?

if(!defined $papersizes{$papersize}) {
    print STDERR "Invalid paper size $papersize\n";
    exit 1;
}

if($orientation eq 'portrait') {
    ($paperwidth, $paperheight) = split ',', $papersizes{$papersize};
} elsif ($orientation eq 'landscape') {
    ($paperheight, $paperwidth) = split ',', $papersizes{$papersize};
} else {
    print STDERR "Invalid paper orientation $orientation\n";
    exit 1;
}
print STDERR "Page width: $paperwidth, height $paperheight\n";
$imagewidth
    = ($paperwidth - $leftmarginwidth - $rightmarginwidth) * $scale/1000;
$imageheight
    = ($paperheight - $lowermarginwidth - $uppermarginwidth) * $scale/1000;

# Work out where the lower left corner is

if($ongraticule) {
    if (defined $lllongitude and defined $lllatitude) {
	my $tzone;
	($tzone, $lleasting, $llnorthing)
	    = latlon_to_utm('WGS-84', $lllatitude, $lllongitude, $zone);
	$zone = $tzone unless defined $zone && $zone;
    } else {
	print STDERR "No location specified\n";
	exit 1;
    }
    if(!defined $graticulewidth) {
	my($tlat, $tlong, undef)
	    = utm_to_latlon('WGS-84', $zone, $lleasting+$imagewidth, $llnorthing);
	$graticulewidth = $tlong - $lllongitude;
    }
    if(!defined $graticuleheight) {
	my($tlat, $tlong, undef)
	    = utm_to_latlon('WGS-84', $zone, $lleasting, $llnorthing+$imageheight);
	$graticuleheight = $tlat - $lllatitude;
    }
    $lrlongitude = $urlongitude = $lllongitude + $graticulewidth;
    $ullatitude = $urlatitude = $lllatitude + $graticuleheight;
    $ullongitude = $lllongitude;
    $lrlatitude = $lllatitude;
    (undef, $lleasting, $llnorthing)
	= latlon_to_utm('WGS-84', $lllatitude, $lllongitude, $zone);
    (undef, $lreasting, $lrnorthing)
	= latlon_to_utm('WGS-84', $lrlatitude, $lrlongitude, $zone);
    (undef, $uleasting, $ulnorthing)
	= latlon_to_utm('WGS-84', $ullatitude, $ullongitude, $zone);
    (undef, $ureasting, $urnorthing)
	= latlon_to_utm('WGS-84', $urlatitude, $urlongitude, $zone);
} else { # on grid
    if(!defined $lleasting or !defined $llnorthing or !defined $zone) {
	print STDERR "No location specified\n";
	exit 1;
    }
    if(!defined $gridwidth) {
	$gridwidth = $imagewidth;
    }
    if(!defined $gridheight) {
	$gridheight = $imageheight;
    }
    $ureasting = $lreasting = $lleasting + $gridwidth;
    $uleasting = $lleasting;
    $urnorthing = $ulnorthing = $llnorthing + $gridheight;
    $lrnorthing = $llnorthing;
    print STDERR "About to calculate bounding box (zone $zone)\n";
    ($lllatitude, $lllongitude, undef)
	= utm_to_latlon('WGS-84', $zone, $lleasting, $llnorthing);
    ($lrlatitude, $lrlongitude, undef)
	= utm_to_latlon('WGS-84', $zone, $lreasting, $lrnorthing);
    ($ullatitude, $ullongitude, undef)
	= utm_to_latlon('WGS-84', $zone, $uleasting, $ulnorthing);
    ($urlatitude, $urlongitude, undef)
	= utm_to_latlon('WGS-84', $zone, $ureasting, $urnorthing);
    print STDERR "$lllatitude $lllongitude $urlatitude $urlongitude\n";
}

print STDERR "width $graticulewidth; height $graticuleheight\n";

if($bleedright) {
    my (undef, $teast, $tnorth)
	= latlon_to_utm('WGS-84', $urlatitude, $lllongitude, $zone);
    my (undef, $urlatitude, $urlongitude)
	= utm_to_latlon('WGS-84', $zone, $teast+$imagewidth, $tnorth);

}

if($bleedtop) {
    my (undef, $teast, $tnorth)
	= latlon_to_utm('WGS-84', $lllatitude, $urlongitude, $zone);
    my (undef, $urlatitude, $urlongitude)
	= utm_to_latlon('WGS-84', $zone, $teast+$imagewidth, $tnorth);
}

print STDERR <<EOF;
Grid corners:
    $uleasting $ulnorthing   $ureasting $urnorthing
    $lleasting $llnorthing   $lreasting $lrnorthing
EOF

open TMP, "+>/tmp/$$";
unlink "/tmp/$$"; # saves cleaning up later

print <<EOF;
%!PS-Adobe
% This product incorporates data which is Copyright State of Victoria 2001-2013
$papersize
72 25.4 div dup scale
EOF

print "$paperheight 0 translate 90 rotate\n" if $orientation eq 'landscape';

print <<EOF;
/Helvetica findfont
dup length dict begin
{ 1 index /FID ne {def} {pop pop} ifelse } forall
/Encoding ISOLatin1Encoding def
currentdict
end
/Helvetica-Latin1 exch definefont pop

/Helvetica-Narrow findfont
dup length dict begin
{ 1 index /FID ne {def} {pop pop} ifelse } forall
/Encoding ISOLatin1Encoding def
currentdict
end
/Helvetica-Narrow-Latin1 exch definefont pop

/Helvetica-Narrow-Oblique findfont
dup length dict begin
{ 1 index /FID ne {def} {pop pop} ifelse } forall
/Encoding ISOLatin1Encoding def
currentdict
end
/Helvetica-Narrow-Oblique-Latin1 exch definefont pop

/Helvetica-Narrow-BoldOblique findfont
dup length dict begin
{ 1 index /FID ne {def} {pop pop} ifelse } forall
/Encoding ISOLatin1Encoding def
currentdict
end
/Helvetica-Narrow-BoldOblique-Latin1 exch definefont pop

/Helvetica-BoldOblique findfont
dup length dict begin
{ 1 index /FID ne {def} {pop pop} ifelse } forall
/Encoding ISOLatin1Encoding def
currentdict
end
/Helvetica-BoldOblique-Latin1 exch definefont pop

EOF

    if($lowermarginwidth > 20) {
	print <<EOF;
/Helvetica-Narrow-Latin1 3 selectfont
8 8 moveto
(This product incorporates data which is Copyright\\251 State of Victoria 2001-2013) show
EOF
}

my %dependencies;

my $rect;

use vars qw($xoffset $yoffset $xmin $ymin);
$xmin = $leftmarginwidth;
$ymin = $lowermarginwidth;
# The following four variables are used to do rough clipping during drawing
my ($minx, $miny, $maxx, $maxy);
$minx = $lllongitude - .001;
$maxx = $urlongitude + .001;
$miny = $lllatitude - .001;
$maxy = $urlatitude + .001;

my $xscale = 1000/$scale; # convert metres on the ground to mm on the map
my $yscale = $xscale;

my $dbh = DBI->connect("dbi:Pg:dbname=$db", "", "", {AutoCommit => 0});

# Get featuretypes

#my $sth = $dbh->prepare("SELECT type, name FROM featuretype");
#
#$sth->execute();
#   
#while ( my @row = $sth->fetchrow_array ) {
#  my $type = $row[0];
#  my $name = $row[1];
#  $featuretype[$type] = $name;
#  $featuretype{$name} = $type;
#  $display_feature[$type] = 1; # display everything by default
#  $display_feature[$type] = 0 if defined $nofeature{$name};
#  #print STDERR "$type $name $display_feature[$type]\n";
#}

my $point_count = 0;
my $object_count = 0;
    
sub grid2page {
    my ($xin, $yin) = @_;
    my $xout = $xin + $xoffset;
    my $yout = $yin + $yoffset;
    $xout *= $xscale;
    $yout *= $yscale;
    $xout += $xmin;
    $yout += $ymin;
    return ($xout, $yout);
}

sub latlon2page {
    my ($zone, $xin, $yin) = @_;
    ++$point_count;
    my (undef, $xout, $yout) = latlon_to_utm('WGS-84', $yin, $xin, $zone);
    return grid2page($xout, $yout);
}

sub sbsb {
    my ($s1, $b1, $s2, $b2) = @_;
    print TMP <<EOF;
/Helvetica-Latin1 4 selectfont
($b2) stringwidth pop ($b1) stringwidth pop add
/Helvetica-Latin1 2 selectfont
($s1) stringwidth pop ($s2) stringwidth pop add add
2 div neg 0 moveto
($s1) show
/Helvetica-Latin1 4 selectfont ($b1) show
/Helvetica-Latin1 2 selectfont ($s2) show
/Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub lsbsb {
    my ($s1, $b1, $s2, $b2) = @_;
    print TMP <<EOF;
0 0 moveto
/Helvetica-Latin1 2 selectfont ($s1) show
/Helvetica-Latin1 4 selectfont ($b1) show
/Helvetica-Latin1 2 selectfont ($s2) show
/Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub rsbsb {
    my ($s1, $b1, $s2, $b2) = @_;
    print TMP <<EOF;
/Helvetica-Latin1 4 selectfont
($b2) stringwidth pop ($b1) stringwidth pop add
/Helvetica-Latin1 2 selectfont
($s1) stringwidth pop ($s2) stringwidth pop add add
neg 0 moveto
($s1) show
/Helvetica-Latin1 4 selectfont ($b1) show
/Helvetica-Latin1 2 selectfont ($s2) show
/Helvetica-Latin1 4 selectfont ($b2) show
EOF
}

sub get_ann_string {
    my $element = shift;
    my $length = unpack "V", substr($element, 0, 4);
    substr($element, 0, 4) = '';
    my $string = '';
    while($length > 0) {
	$string .= substr($element, 0, 1);
	substr($element, 0, 2) = '';
	$length -= 2;
    }
    $string =~ s/\000$//;
    return ($string, $element);
}

sub get_ann_astring {
    my $element = shift;
    my $length = ord(substr($element, 0, 1));
    substr($element, 0, 1) = '';
    my $string = substr($element, 0, $length);
    substr($element, 0, $length) = '';
    return ($string, $element);
}

sub ann_lastring {
    my $element = shift;
    my $length = unpack "V", substr($element, 0, 4);
    substr($element, 0, 4) = '';
    my $string = substr($element, 0, $length);
    substr($element, 0, $length) = '';
    return ($string, $element);
}

sub ann_byte {
    my $element = shift;
    my $val = unpack "C", $element;
    return $val;
}

sub ann_short {
    my $element = shift;
    my $val = unpack "v", $element;
    return $val;
}

sub ann_int {
    my $element = shift;
    my $val = unpack "V", $element;
    return $val;
}

sub ann_double {
    my $element = shift;
    my $val = unpack "d", $element;
    return $val;
}

sub ann_colour {
    my $element = shift;
    my ($cyan, $magenta, $yellow, $black) = unpack "CCCC", $element;
    #print STDERR "Colour: $cyan $magenta $yellow $black\n";
    $cyan /= 100;
    $magenta /= 100;
    $yellow /= 100;
    $black /= 100;
    return ($cyan, $magenta, $yellow, $black);
}

sub latlon2string {
    my ($val, $dirs, $full) = @_;
    my $dir;
    if ($val < 0) {
	$val = - $val;
	$dir = substr($dirs, 1, 1);
    } else {
	$dir = substr($dirs, 0, 1);
    }
    $full = 1 if $val == int $val;
    $val += .01;
    my $int = int $val;
    my $frac = $val - $int;
    my $string = '';
    $string = "$int\\260 " if $full;
    $frac = int ($frac*60);
    $string .= sprintf "%02d'", $frac;
    $string .= " $dir" if $full;
    return $string;
}

# These functions do clever things to avoid plotting too many points
# outside the clipping boundary, while not literally cutting corners
# when a line moves back inside the clip boundary.

my $moveto;
my $quadrant = -1;
my $prev_x;
my $prev_y;

sub plot_point {
    my ($zone, $x, $y, $moveto) = @_;
    
    my ($x1, $y1) = latlon2page $zone, $x, $y;
    printf TMP "%.5g %.5g %s\n", $x1, $y1, $moveto?'moveto':'lineto';
}

my $prev_moveto;
sub plot_previous_point {
    my $zone = shift;
    if (defined $prev_x and defined $prev_y && !$prev_moveto) {
#	print TMP "%plot_previous_point $zone $prev_x $prev_y $prev_moveto\n";
	plot_point($zone, $prev_x, $prev_y, $prev_moveto);
	undef $prev_x;
	undef $prev_y;
    }
}

sub add_point {
    my ($zone, $x, $y) = @_;
    my $new_quadrant = 5;

    return unless defined $x and defined $y;

    $new_quadrant -= 1 if $x < $minx;
    $new_quadrant += 1 if $x > $maxx;
    $new_quadrant += 3 if $y < $miny;
    $new_quadrant -= 3 if $y > $maxy;
    
#    print TMP "%add_point: $zone $x $y\n";
    if ($quadrant == 5 || $quadrant != $new_quadrant) {
	plot_previous_point($zone) if $quadrant != 5;
	plot_point($zone, $x, $y, $moveto);
	undef $prev_x;
	undef $prev_y;
	$moveto = 0;
    } else {
	$prev_x = $x;
	$prev_y = $y;
	$prev_moveto = $moveto;
    }
    $quadrant = $new_quadrant;
}

sub put_line {
    my ($zone, $shape, $func, $featurewidth) = @_;

    undef $prev_x;
    undef $prev_y;

#print STDERR "put_line: $shape\n";
#    print TMP "% $zone $shape\n";
    $shape =~ s/^MULTILINESTRING\(\(//;
    $shape =~ s/\)\)$//;
    my @segments = split '\)\,?\s*\(', $shape;
    for my $segment (@segments) {
#print STDERR "segment: $segment\n";
	$quadrant = -1;
	$moveto = 1;
	my @points = split ',', $segment;
#print STDERR "$#points points\n";
	for my $point (@points)	{
	    #print STDERR "$point\n";
	    #print TMP "% $zone $point\n";
	    $point =~ /(\-?[\d\.]+)\s+(\-?[\d\.]+)/;
	    add_point($zone, $1, $2);
	}
	plot_previous_point($zone) if $quadrant != 5;
    }
    plot_previous_point($zone) if $quadrant != 5;
    print TMP "$featurewidth $func\n";
    $dependencies{$func}++;
}

my $sth_sym = $dbh->prepare("SELECT symbol_ga FROM vicmap_symbols WHERE type = ? AND ftype = ?");

my %symbol = (
);

sub get_symbol {
    my $type = shift;
    my $ftype = shift;
    return $symbol{"$type:$ftype"} if defined $symbol{"$type:$ftype"};
    print STDERR "Looking for $ftype($type)\n";
    $sth_sym->execute($type, $ftype);
    my $sym = 0;
    while( my ($tsym) = $sth_sym->fetchrow_array()) {
	$sym = $tsym;
	print STDERR "Found $sym\n";
    }
    $symbol{"$type:$ftype"} = $sym;
    print STDERR "Unknown $type symbol $ftype\n" unless $sym;
    return $sym;
}

sub draw_areas {
    my ($zone, $table) = @_;

    print STDERR "$table areas...\n";
    my $sth = $dbh->prepare("SELECT ftype_code, st_astext(the_geom) as shape FROM $table WHERE the_geom && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $ftype = $row[0];
	my $shape = $row[1];
	
        my $symbol = get_symbol('area', $ftype);

	next unless $symbol;
	++$object_count;
	put_line($zone, $shape, "area$symbol", '');
    }
}

my $powerlinestart = 1;
my $powerdirection = 1;
my $tickdirection = 0;

sub powerline {
    my ($x, $y, $angle, $width, $thick, $colour) = @_;
#   print TMP " % powerline: at $x, $y angle $angle\n";
    if($powerlinestart) {
	$powerlinestart = 0;
	$powerdirection = 1;
	print TMP "$x $y moveto\n";
    } else {
        $angle *= 3.14159265 / 180;
	my $nx = $x - $thick / 2 * sin($angle) * $powerdirection;
	my $ny = $y + $thick / 2 * cos($angle) * $powerdirection;
	print TMP "$nx $ny lineto\n";
	$powerdirection = $powerdirection > 0 ? -1 : 1;
    }
}

sub leftticks {
    my ($x, $y, $angle, $width, $thick, $colour) = @_;
#   print STDERR "lefttick: at $x, $y angle $angle\n";
    print TMP "gsave $x $y translate $angle rotate $colour setcmykcolor $thick setlinewidth 0 0 moveto 0 $width lineto stroke grestore\n";
}

sub altticks {
    my ($x, $y, $angle, $width, $thick, $colour) = @_;
    $width *= -1 if $tickdirection;
    print TMP "gsave $x $y translate $angle rotate $colour setcmykcolor $thick setlinewidth 0 0 moveto 0 $width lineto stroke grestore\n";
    $tickdirection = $tickdirection ? 0 : 1;
}

sub follow_line {
    my ($zone, $shape, $spacing, $func, $width, $thick, $colour) = @_;

    my ($oldx, $oldy);
    my $counter = $spacing / 2;

    $shape =~ s/^MULTILINESTRING\(\(//;
    $shape =~ s/\)\)$//;
    my @segments = split '\)\,\s*\(', $shape;
    for my $segment (@segments) {
	my @points = split '\,\s*', $segment;
	for my $point (@points)	{
	    $point =~ /(\-?[\d\.]+)\s+(\-?[\d\.]+)/;
	    my ($x, $y) = latlon2page $zone, $1, $2;
	    if (defined $oldx) {
		my $deltax = $x - $oldx;
		my $deltay = $y - $oldy;
		my $length = sqrt($deltax * $deltax + $deltay * $deltay);
		#print STDERR "follow_line from ($oldx, $oldy) to ($x, $y) diff ($deltax, $deltay) length $length start $counter\n";
		if ($length >= $counter) {
		    my $angle = atan2($deltay, $deltax) * 180 / 3.1415926535;
		    my $l;
		    for($l = $counter;
			$l <= $length;
			$l += $spacing) {
			my $frac = $l / $length;
			my $tx = $oldx + $deltax * $frac;
			my $ty = $oldy + $deltay * $frac;
			&$func($tx, $ty, $angle, $width, $thick, $colour);
			$counter -= $spacing;
		    }
		    $counter = $l - $length;
		} else {
		    $counter -= $length;
		}
	    }
	    $oldx = $x;
	    $oldy = $y;
	}
    }
#    print TMP "$featurewidth $func\n";
}

sub draw_ftype {
    my ($zone, $table, $symbol) = @_;

    print STDERR "$table lines...\n";
    my $sth = $dbh->prepare("SELECT ftype, st_astext(the_geom) as shape FROM $table WHERE the_geom && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $ftype = $row[0];
	my $shape = $row[1];
	
#	my $symbol = 80;
#	if (defined $default_symbol and $default_symbol < 0) {
#	    $symbol = -$default_symbol;
#	} else {
#            $symbol = get_symbol('line', $ftype);
#	}
#	$symbol = $default_symbol if defined $default_symbol and ! $symbol;
	next unless $symbol;
	++$object_count;
	put_line($zone, $shape, "line$symbol", 0);
    }
}

sub draw_lines {
    my ($zone, $table, $default_symbol) = @_;

    print STDERR "$table lines...\n";
    my $sth = $dbh->prepare("SELECT ftype_code, st_astext(the_geom) as shape FROM $table WHERE the_geom && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $ftype = $row[0];
	my $shape = $row[1];
	
	my $symbol = 0;
	if (defined $default_symbol and $default_symbol < 0) {
	    $symbol = -$default_symbol;
	} else {
            $symbol = get_symbol('line', $ftype);
	}
	$symbol = $default_symbol if defined $default_symbol and ! $symbol;
	next unless $symbol;
	++$object_count;
	if($symbol == 57) { # Depression contour (index)
	} elsif ($symbol ==  58) { # Depression contour (standard)
	    put_line($zone, $shape, "line58A", 0);
	    follow_line($zone, $shape, 4, \&leftticks, .3, .15, '0 .59 1 .18');
	} elsif ($symbol ==  31) { # Embankment
	} elsif ($symbol == 542) { # Powerline
	    $powerlinestart = 1;
	    follow_line($zone, $shape, .5, \&powerline, .5, .2, '1 .73 0 0');
	    print TMP "1 .73 0 0 setcmykcolor .2 setlinewidth stroke\n";
	} elsif ($symbol == 543) { # Powerline (WAC)
	    $powerlinestart = 1;
	    follow_line($zone, $shape, .5, \&powerline, .5, .2, '.79 .9 0 0');
	    print TMP ".79 .9 0 0 setcmykcolor .2 setlinewidth stroke\n";
	} elsif ($symbol == 920) { # Cliff (WAC)
	    put_line($zone, $shape, "line920A", 0);
	    follow_line($zone, $shape, 1, \&leftticks, .4, .15, '0 .59 1 .18');
	} elsif ($symbol == 923) { # Cutting
	} elsif ($symbol == 924) { # Cliff
	    put_line($zone, $shape, "line924A", 0);
	    follow_line($zone, $shape, 1, \&leftticks, .4, .15, '0 0 0 1');
	} elsif ($symbol == 929) { # Razorback
	    put_line($zone, $shape, "line929A", 0);
	    follow_line($zone, $shape, 1, \&altticks, .4, .15, '0 0 0 1');
	} else {
	    put_line($zone, $shape, "line$symbol", 0);
	}
    }
}

sub draw_wlines {
    my ($zone, $table, $default_symbol) = @_;

    print STDERR "$table lines...\n";
    my $sth = $dbh->prepare("SELECT symbol, st_astext(shape) as shape, featurewidth FROM $table WHERE shape && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $symbol = $row[0];
	my $shape = $row[1];
	my $featurewidth = $row[3];
	$featurewidth = 0 unless defined $featurewidth && $featurewidth;
	
	if (defined $default_symbol and $default_symbol < 0) {
	    $symbol = -$default_symbol;
	}
	$symbol = $default_symbol if defined $default_symbol and ! $symbol;
	next unless $symbol;
	++$object_count;
	if($symbol == 57) { # Depression contour (index)
	} elsif($symbol == 58) { # Depression contour (standard)
	} elsif ($symbol == 31) { # Embankment
	} elsif ($symbol == 542) { # Powerline
	} elsif ($symbol == 543) { # Powerline (WAC)
	} elsif ($symbol == 920) { # Cliff (WAC)
	} elsif ($symbol == 923) { # Cutting
	} elsif ($symbol == 924) { # Cliff
	} elsif ($symbol == 929) { # Razorback
	} else {
	    put_line($zone, $shape, "line$symbol", $featurewidth);
	}
    }
}

my %roadsymbols = (
  'road_0s' => 250, # dual carriageway
  'road_1s' => 251, # principal sealed
  'road_2s' => 251, # principal sealed
  'road_3s' => 256, # secondary sealed
  'road_4s' => 256, # secondary sealed
  'road_5s' => 256, # secondary sealed
  'road_6s' => 257, # minor sealed
  'road_7s' => 257, # minor sealed
  'road_8s' => 257, # minor sealed
  'road_9s' => 257, # minor sealed
  'road_10s' => 257, # minor sealed
  'road_11s' => 257, # minor sealed
  'road_0u' => 258, # principal unsealed
  'road_1u' => 258, # principal unsealed
  'road_2u' => 258, # principal unsealed
  'road_3u' => 259, # secondary unsealed
  'road_4u' => 259, # secondary unsealed
  'road_5u' => 259, # secondary unsealed
  'road_6u' => 253, # minor unsealed
  'road_7u' => 253, # minor unsealed
  'road_8u' => 254, # vehicular track
  'road_9u' => 254, # vehicular track
  'road_10u' => 254, # vehicular track
  'road_11u' => 254, # vehicular track
  'footbridge' => 268, # foot bridge
);

sub draw_roads {
    my $zone = shift;
    my @dual = ();
    my $featurewidth;

    print STDERR "Roads...\n";
    my $sth = $dbh->prepare("SELECT pfi, ftype_code, class_code, dir_code, road_seal, div_rd, st_astext(the_geom) as shape FROM tr_road WHERE the_geom && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $objectid = $row[0];
	my $ftype_code = $row[1];
	my $featurewidth = 0;
        my $class = $row[2];
        my $dir = $row[3];
        my $sealed = $row[4];
        my $divided = $row[5];
	my $shape = $row[6];
	#$featurewidth = 0 unless defined $featurewidth && $featurewidth;
	
        $sealed = ($sealed == 1) ? 's' : 'u';
        my $symbol = $roadsymbols{"${ftype_code}_$class$sealed"};
	next unless $symbol;
	push @dual, $objectid if $symbol == 250;
	++$object_count;
	put_line($zone, $shape, "line$symbol", $featurewidth);
    }

# Now go back and draw the yellow centre line on dual carriageways

    $sth = $dbh->prepare("SELECT symbol, st_astext(shape) as shape FROM Roads WHERE objectid = ?");
    for my $objectid (@dual) {
	$sth->execute($objectid);
	
	while ( my @row = $sth->fetchrow_array ) {
	    my $symbol = $row[0];
	    my $shape = $row[1];
	    
	    put_line($zone, $shape, 'line250A', $featurewidth);
	}
    }
}

my %osmroads2ga = (
    'motorway' => 250,
    'trunk' => 250,
    'primary' => 250,
    'motorway_link' => 251,
    'secondary' => 251,
    'trunk' => 251,
    'trunl_link' => 256,
    'tertiary' => 256,
    'unclassified' => 257,
    'road' => 257,
    'service' => 257,
    'residential' => 257,
    'track' => 254,
    'footway' => 22,
    'path' => 22,
    'cycleway' => 22,
    );

sub draw_osmroads {
    my $zone = shift;
    my @dual = ();
    my $featurewidth;

    print STDERR "OSMRoads...\n";
    my $osmdbh = DBI->connect("dbi:Pg:dbname=osm", "", "", {AutoCommit => 0});
    my $sth = $osmdbh->prepare("SELECT objectid, type, st_astext(shape) as shape FROM HighwayWays WHERE shape && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $objectid = $row[0];
	my $type = $row[1];
	my $shape = $row[2];
	my $symbol = $osmroads2ga{$type};
	if(defined $symbol) {
	    $featurewidth = 0 unless defined $featurewidth && $featurewidth;
	    
	    next unless $symbol;
	    push @dual, $objectid if $symbol == 250;
	    ++$object_count;
	    put_line($zone, $shape, "line$symbol", $featurewidth);
	} else {
	    print STDERR "Unknown road type $type\n";
	}
    }

# Now go back and draw the yellow centre line on dual carriageways

    $sth = $osmdbh->prepare("SELECT shape FROM HighwayWays WHERE objectid = ?");
    for my $objectid (@dual) {
	$sth->execute($objectid);
	
	while (my @row = $sth->fetchrow_array) {
	    my $shape = $row[0];
	    
	    put_line($zone, $shape, 'line250A', $featurewidth);
	}
    }
    $osmdbh->disconnect();
}

sub min {
    my $a = shift;
    my $b = shift;
    return $a if $a <= $b;
    return $b;
}

sub max {
    my $a = shift;
    my $b = shift;
    return $a if $a >= $b;
    return $b;
}

sub draw_points {
    my ($zone, $table) = @_;

    print STDERR "$table points...\n";
    my $sth = $dbh->prepare("SELECT ftype_code, st_astext(the_geom) as position, rotation FROM $table WHERE the_geom && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	my $ftype = $row[0];
	my $position = $row[1];
	my $orientation = 90 - $row[2] || 0;
	my $featurewidth = 0;
	my $featuretype = $ftype;

        my $symbol = get_symbol('point', $ftype);
	
	#next unless $display_feature[$featuretype]; ### TODO
	next unless $symbol;
	++$object_count;
	$position =~ /\((\-?[\d\.]+)\s+(\-?[\d\.]+)\)/;
	my ($x, $y) = latlon2page $zone, $1, $2;
	$dependencies{"point$symbol"}++;
	printf TMP "$orientation %.6g %.6g $featurewidth point$symbol\n", $x, $y;
    }
}

sub draw_annotations {
    my $zone = shift;
    print STDERR "Annotations...\n";
    my $sth = $dbh->prepare("SELECT element, st_astext(shape) as shape FROM Annotations WHERE shape && $rect");
    
    $sth->execute();
    
    while ( my @row = $sth->fetchrow_array ) {
	++$object_count;
	my $element = $row[0];
	my $shape = $row[1];
	my ($string2, $string3, $font);
	my ($x1, $y1, $x2, $y2);
	my $unknown1;
	my $justn = 0;
	my ($rotangle, $xdiff, $ydiff);
	
	#{my $el = $element; while ($el) {printf TMP "%02.2x ", ord(substr($el, 0, 1)); substr($el, 0, 1) = ''; } print TMP "\n";}
	substr($element, 0, 54) = ''; # first 54 bytes are invariant
	($string2, $element) = get_ann_string($element);
	#print STDERR "draw_annotation: $string2\n";
	$unknown1 = substr($element, 0, 1); # What is this?
	substr($element, 0, 22) = ''; # 21 invariant bytes
	$unknown1 = substr($element, 0, 1);
	substr($element, 0, 16) = ''; # 15 invariant bytes
	$unknown1 = ann_short(substr($element, 0, 2)); substr($element, 0, 2) = '';
	$unknown1 = ann_short(substr($element, 0, 2)); substr($element, 0, 2) = '';
	my ($cyan, $magenta, $yellow, $black) = ann_colour(substr($element, 0, 4));
	#print STDERR "colour: $cyan $magenta $yellow $black\n";
	substr($element, 0, 6) = ''; # 2 invariant bytes
	$unknown1 = ann_int(substr($element, 0, 4)); substr($element, 0, 4) = '';
	substr($element, 0, 21) = '' if ($unknown1 == 0);
	$unknown1 = ann_int(substr($element, 0, 4)); substr($element, 0, 4) = '';
	$justn = ann_int(substr($element, 0, 4));
	substr($element, 0, 6) = ''; # 2 invariant bytes
	$rotangle = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	$xdiff = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	$ydiff = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
        substr($element, 0, 110) = ''; # invariant bytes
	$unknown1 = ann_short(substr($element, 0, 2)); substr($element, 0, 2) = '';
	substr($element, 0, 61) = '';
	($string3, $element) = get_ann_string($element);
	substr($element, 0, 6) = ''; # invariant
	#print STDERR "Second copy of string: $string3\n";
	my $pointsize = ord(substr($element, 0, 1)); substr($element, 0, 1) = '';
	$pointsize = $pointsize / 4 * 25.4 / 72;
	#print STDERR "Point size: $pointsize\n";
	substr($element, 0, 48) = ''; # invariant
	$unknown1 = ann_byte(substr($element, 0, 1)); substr($element, 0, 1) = '';
	$unknown1 = ann_short(substr($element, 0, 2)); substr($element, 0, 2) = '';
	$pointsize = ann_int(substr($element, 0, 4)); substr($element, 0, 4) = '';
	$pointsize = $pointsize / 10000 * 25.4 / 72;
	($font, $element) = get_ann_astring($element);
	#print STDERR "Font: $font\n";
	substr($element, 0, 18) = ''; # invariant
	$unknown1 = ann_byte(substr($element, 0, 1)); substr($element, 0, 1) = '';
	#print TMP "unknown1: $unknown1\n"; ###
	if ($unknown1 == 16) {
	    substr($element, 0, 17) = ''; # invariant
	    $unknown1 = ann_short(substr($element, 0, 2)); substr($element, 0, 2) = '';
	    substr($element, 0, 6) = '';
	    $x1 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    $y1 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    $x2 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    $y2 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    #print TMP "16: $x1 $y1 $x2 $y2\n"; ###
	    substr($element, 0, 4) = '';
	    my $count = ann_int(substr($element, 0, 4)); substr($element, 0, 4) = '';
	    substr($element, 0, 4) = ''; # invariant
	    #print TMP "count: $count\n"; ###
	    if($count) {
		my @coords = ();
		while($count--) {
		    my $x = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
		    my $y = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
		    push @coords, [$x, $y];
		}
		($x1, $y1) = @{$coords[0]};
		($x2, $y2) = @{$coords[1]};
		if($drawobjects{'annotation_position'}) {
		    my ($tx, $ty) = latlon2page($zone, $x1, $y1);
		    print TMP "%%%%%%%\n$tx $ty moveto\n";
		    for my $posn (@coords) {
			my($x, $y) = @$posn;
			($tx, $ty) = latlon2page($zone, $x, $y);
			print TMP "$tx $ty lineto\n";
		    }
		    print TMP "1 1 0 0 setcmykcolor 0.5 setlinewidth stroke\n";
		}
		$xdiff = 0;
		$ydiff = 0;
		$justn = 0;
	    }
	} elsif ($unknown1 == 65) {
	    substr($element, 0, 17) = ''; # invariant
	    $unknown1 = ann_short(substr($element, 0, 2));
	    substr($element, 0, 8) = ''; # 6 invariant bytes
	    $x1 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    $y1 = ann_double(substr($element, 0, 8)); substr($element, 0, 8) = '';
	    #print STDERR "65: $x1 $y1\n";
	    if($drawobjects{'annotation_position'}) {
		my ($tx, $ty) = latlon2page $zone, $x1, $y1;
		print TMP "$tx $ty moveto 1 0 rlineto 1 1 0 0 setcmykcolor 0.5 setlinewidth stroke %%%%%\n";
	    }
	    $xdiff = $ydiff = 0;
	} else {
	    print STDERR "Unknown annotation value $unknown1, ignoring\n";
	}
	substr($element, 0, 18) = '';
	(undef, $element) = ann_lastring($element);
	substr($element, 0, 41) = ''; # $element should now be empty!
	
	# finished parsing; now print something
	
	# Check for valid location -- sometimes we gat lat/lon with NaN values!
	if($x1 == $x1 and $y1 == $y1) {
	    $font = ($font eq 'Zurich Cn BT') ? 'Helvetica-Narrow-Latin1' : 'Helvetica-Latin1';
	    printf TMP "/$font %.4g selectfont\n", $pointsize;
	    
	    my $annotation = $string2;
	    ($x1, $y1) = latlon2page $zone, $x1, $y1;
	    my $angle;
	    if (defined $y2) {
		($x2, $y2) = latlon2page $zone, $x2, $y2;
		$angle = atan2($y2 - $y1, $x2 - $x1) * 180 / 3.1415926535;
	    } else {
		$angle = 0;
	    }
            # $angle = $rotangle if $rotangle;
	    $annotation =~ s/\\/\\\\/g;
	    $annotation =~ s/\(/\\\(/g;
	    $annotation =~ s/\)/\\\)/g;
	    printf TMP "gsave %.6g %.6g translate %.6g rotate 0 0 moveto %.4g %.4g %.4g %.4g setcmykcolor ", $x1+$xdiff, $y1+$ydiff, $angle, $cyan, $magenta, $yellow, $black;
	    if ($justn == 2) {
		print TMP "($annotation) stringwidth pop neg 0 rmoveto ";
	    } elsif ($justn == 1) {
		print TMP "($annotation) stringwidth pop 2 div neg 0 rmoveto ";
	    }
	    printf TMP "($annotation) show grestore\n";
	}
    }
}

use vars qw($starteasting $mineasting $maxeasting $startnorthing $minnorthing $maxnorthing);

sub label_grid {
    my ($zone, $left, $right) = @_;
    my ($x, $y1, $y2);
    my ($lat, $long, $z);
    my $easting;
# Label grid lines
# Eastings below and above
    ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $starteasting, $minnorthing);
    ($x, $y1) = latlon2page($zone, $long, $lllatitude);
#    ($x, $y1) = grid2page($starteasting, $minnorthing);
    $y1 -= 4;
    ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $starteasting, $maxnorthing);
    ($x, $y2) = latlon2page($zone, $long, $urlatitude);
#    ($x, $y2) = grid2page($starteasting, $maxnorthing);
    $y2 += 1;
    print TMP "gsave $x $y1 translate ";
    $a = $starteasting / $grid_spacing;
    $b = int($a/10);
    $a -= $b*10;
    sbsb($b, $a, '0 000m ', 'E');
    print TMP " grestore\n";
    print TMP "gsave $x $y2 translate ";
    sbsb($b, $a, '0 000m ', 'E');
    print TMP " grestore\n";
    $easting = $starteasting + $grid_spacing;
    
    while ($easting <= $maxeasting) {
	($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $easting, $minnorthing);
	($x, $y1) = latlon2page($zone, $long, $lllatitude);
#	($x, $y1) = grid2page($easting, $minnorthing);
	$y1 -= 4;
	($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $easting, $maxnorthing);
	($x, $y2) = latlon2page($zone, $long, $urlatitude);
#	($x, $y2) = grid2page($easting, $maxnorthing);
	$y2 += 1;
	print TMP "gsave $x $y1 translate\n";
	$a = $easting / $grid_spacing;
	$b = int($a/10);
	$a -= $b*10;
	sbsb($b, $a, '', '');
	print TMP "grestore\n";
	print TMP "gsave $x $y2 translate\n";
	sbsb($b, $a, '', '');
	print TMP "grestore\n";
	$easting += $grid_spacing;
    }
    
# Northings
    if($left) {
	my ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $mineasting, $startnorthing);
	my ($x, $y) = latlon2page($zone, $lllongitude, $lat);
#	my ($x, $y) = grid2page($mineasting, $startnorthing);
	$x -= 1;
	my $a = $startnorthing / $grid_spacing;
	my $b = int($a/10);
	$a -= $b * 10;
	print TMP "gsave $x $y translate 90 rotate\n";
	sbsb($b, $a, '0 000m ', 'N');
	print TMP "grestore\n";
	my $northing = $startnorthing + $grid_spacing;
	
	while ($northing <= $maxnorthing) {
	    ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $mineasting, $northing);
	    ($x, $y) = latlon2page($zone, $lllongitude, $lat);
#	    ($x, $y) = grid2page($mineasting, $northing);
	    $x -= 1;
	    $y -= 2;
	    $a = $northing / $grid_spacing;
	    $b = int($a/10);
	    $a -= $b * 10;
	    print TMP "gsave $x $y translate\n";
	    rsbsb($b, $a, '', '');
	    print TMP "grestore\n";
	    $northing += $grid_spacing;
	}
    }	
    if ($right) {
	my ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $maxeasting, $startnorthing);
	my ($x, $y) = latlon2page($zone, $urlongitude, $lat);
#	my ($x, $y) = grid2page($maxeasting, $startnorthing);
	$x += 4;
	my $a = $startnorthing / $grid_spacing;
	my $b = int($a/10);
	$a -= $b * 10;
	print TMP "gsave $x $y translate 90 rotate\n";
	sbsb($b, $a, '0 000m ', 'N');
	print TMP "grestore\n";
	my $northing = $startnorthing + $grid_spacing;
	
	while ($northing <= $maxnorthing) {
	    ($lat, $long, $z) = utm_to_latlon('WGS-84', $zone, $maxeasting, $northing);
	    ($x, $y) = latlon2page($zone, $urlongitude, $lat);
#	    ($x, $y) = grid2page($maxeasting, $northing);
	    $x += 1;
	    $y -= 2;
	    $a = $northing / $grid_spacing;
	    $b = int($a/10);
	    $a -= $b * 10;
	    print TMP "gsave $x $y translate\n";
	    lsbsb($b, $a, '', '');
	    print TMP "grestore\n";
	    $northing += $grid_spacing;
	}
    }
}

sub label_graticule {    
    my ($zone, $left, $right) = @_;
# Now label the lines of longitude and latitude:
    
    print TMP "0 0 0 1 setcmykcolor /Helvetica-Latin1 4 selectfont\n";
    
    my $startlat = (int ($lllatitude/$graticule_spacing)) * $graticule_spacing;
    $startlat += $graticule_spacing if $startlat < $lllatitude;
    my $startlong = (int ($lllongitude/$graticule_spacing)) * $graticule_spacing;
    $startlong += $graticule_spacing if $startlong < $lllongitude;
    
# Longitude
    
    my $long = $startlong;
    
    my $first = 1;
    while ($long < $urlongitude + .0001) {
	my $lat = $lllatitude;
	my ($x, $y) = latlon2page $zone, $long, $lllatitude;
	$y -= 10;
	my $string = latlon2string($long, "EW", $first);
	print TMP "$x $y moveto ($string) dup stringwidth pop 2 div neg 0 rmoveto show\n" unless ($first && ! $left);
	($x, $y) = latlon2page $zone, $long, $urlatitude;
	$y += 7;
	print TMP "$x $y moveto ($string) dup stringwidth pop 2 div neg 0 rmoveto show\n" unless ($first && !$left);
	$long += $graticule_spacing;
	$first = 0;
    }
    
# Latitude
    
    if($left) {
	my $lat = $startlat;
	
	$first = 1;
	while ($lat < $urlatitude + .0001) {
	    print TMP "% Latitude $lat\n";
	    my $long = $lllongitude;
	    my ($x, $y) = latlon2page $zone, $long, $lat;
	    $x -= 7;
	    $y -= 2;
	    my $string = latlon2string $lat, "NS", $first;
	    print TMP "$x $y moveto ($string) dup stringwidth pop neg 0 rmoveto show\n";
	    $lat += $graticule_spacing;
	    $first = 0;
	}
    }
    if ($right) {
	print TMP "0 0 0 1 setcmykcolor /Helvetica-Latin1 4 selectfont\n";
# Latitude
	
	my $lat = $startlat;
	
	$first = 1;
	while ($lat < $urlatitude + .0001) {
	    print TMP "% Latitude $lat\n";
	    my $long = $lllongitude;
	    my $string = latlon2string $lat, "NS", $first;
	    my ($x, $y) = latlon2page $zone, $urlongitude, $lat;
	    $x += 7;
	    $y -= 2;
	    print TMP "$x $y moveto ($string) show\n";
	    $lat += $graticule_spacing;
	    $first = 0;
	}
    }
}

sub draw_graticule {
    my $zone = shift;
# Now draw the lines of longitude and latitude:

    my $minlat = (int ($lllatitude/$graticule_spacing)) * $graticule_spacing;
    $minlat += $graticule_spacing if $minlat < $lllatitude;
    my $minlong = (int ($lllongitude/$graticule_spacing)) * $graticule_spacing;
    $minlong += $graticule_spacing if $minlong < $lllongitude;
    
# Longitude
    
    my $long = $minlong;
    
print TMP "% draw graticule from $minlong, $minlat to $urlongitude, $urlatitude\n";
    while ($long < $urlongitude + .0001) {
	my $lat = $lllatitude;
	my ($x, $y) = latlon2page $zone, $long, $lat;
	print TMP "% Longitude $long\n";
	print TMP ".1 setlinewidth 0 0 0 1 setcmykcolor\n";
	print TMP "$x $y moveto\n";
	$lat += 1.0/60.0;
	while ($lat <= $urlatitude + .0001) {
	    ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y lineto\n";
	    $lat += 1.0/60.0;
	}
	print TMP "stroke\n";
	$long += $graticule_spacing;
    }
    
# Longitude ticks
    
    $long = $minlong;
    
    while ($long < $urlongitude + .0001) {
	my $lat = (int($lllatitude*60))/60;;
	my ($x, $y) = latlon2page $zone, $long, $lat;
	while ($lat <= $urlatitude + .0001) {
	    ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y moveto -.5 0 rlineto 1 0 rlineto stroke\n";
	    $lat += 1.0/60.0;
	}
	print TMP "stroke\n";
	$long += $graticule_spacing;
    }
    
    $long = $minlong;
    
    while ($long < $urlongitude + .0001) {
	my $lat = (int($lllatitude*12))/12;;
	my ($x, $y) = latlon2page $zone, $long, $lat;
	while ($lat <= $urlatitude + .0001) {
	    ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y moveto -1 0 rlineto 2 0 rlineto stroke\n";
	    $lat += 5.0/60.0;
	}
	print TMP "stroke\n";
	$long += $graticule_spacing;
    }
    
# Latitude
    
    my $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
	my $long = $lllongitude;
	my ($x, $y) = latlon2page $zone, $long, $lat;
	print TMP "% Latitude $lat\n";
	print TMP "$x $y moveto\n";
	$long += 1.0/60.0;
	while ($long <= $urlongitude + .1) {
	    ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y lineto % $zone $long $lat\n";
	    $long += 1.0/60.0;
	}
	print TMP "stroke % latitude\n";
	$lat += $graticule_spacing;
    }
    
# Latitude ticks
    
    $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
	my $long = (int($lllongitude*60))/60;;
	while ($long <= $urlongitude + .0001) {
	    my ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y moveto 0 -.5 rlineto 0 1 rlineto stroke\n";
	    $long += 1.0/60.0;
	}
	print TMP "stroke\n";
	$lat += $graticule_spacing;
    }
    
    $lat = $minlat;
    
    while ($lat < $urlatitude + .0001) {
	my $long = (int($lllongitude*12))/12;;
	while ($long <= $urlongitude + .0001) {
	    my ($x, $y) = latlon2page $zone, $long, $lat;
	    print TMP "$x $y moveto 0 -1 rlineto 0 2 rlineto stroke\n";
	    $long += 5.0/60.0;
	}
	print TMP "stroke\n";
	$lat += $graticule_spacing;
    }
}
    
sub draw_grid {
    my $zone = shift;
# Finally draw the blue grid
    
    print TMP "1 .1 0 .1 setcmykcolor\ngsave\n";

    $minnorthing = min($llnorthing, $lrnorthing);
    $startnorthing = (int (($minnorthing+($grid_spacing-1))/$grid_spacing)) * $grid_spacing;
    $mineasting = min($lleasting, $uleasting);
    $starteasting = (int (($mineasting+($grid_spacing-1))/$grid_spacing)) * $grid_spacing;
    my $maxeasting = max($lreasting, $ureasting);
    my $maxnorthing = max($ulnorthing, $urnorthing);
    
print TMP "% draw grid: $mineasting, $minnorthing to $maxeasting, $maxnorthing by  $grid_spacing\n";
    my $easting = $starteasting;
    while ($easting <= $maxeasting) {
	my ($x1, $y1) = grid2page($easting, $minnorthing);
	my ($x2, $y2) = grid2page($easting, $maxnorthing);
	print TMP "$x1 $y1 moveto $x2 $y2 lineto stroke\n";
	$easting += $grid_spacing;
    }
    
    my $northing = $startnorthing;
    while ($northing <= $maxnorthing) {
	my ($x1, $y1) = grid2page($mineasting, $northing);
	my ($x2, $y2) = grid2page($maxeasting, $northing);
	print TMP "$x1 $y1 moveto $x2 $y2 lineto stroke\n";
	$northing += $grid_spacing;
    }
    print TMP "grestore\n";
}

sub format_dms {
    my ($lat, $pos, $neg) = @_;
    my $string = '';
    my $hemisphere = $lat >= 0 ? $pos : $neg;
    $lat = - $lat if $lat < 0;
    my $deg = int $lat;
    $lat = ($lat-$deg) * 60;
    my $min = int $lat;
    my $sec = ($lat-$min) * 60;
    if ($sec >= 60) {
	$min++;
	$sec -= 60;
    }
    if ($min >= 60) {
	$deg++;
	$min -= 60;
    }
    $string = sprintf "%d\\260%d'%.2f\" %s", $deg, $min, $sec, $hemisphere;
    return $string;
}

sub format_lat {
    my $lat = shift;
    return format_dms($lat, 'N', 'S');
}

sub format_long {
    my $long = shift;
    return format_dms($long, 'E', 'W');
}

sub put_annotation {
    my $zone = shift;
    my $pagex = shift;
    my $pagey = shift;
    my $long = shift;
    my $lat = shift;
    my $x1 = shift;
    my $y1 = shift;
    my $string = shift;
    my $longstr = format_long($long);
    my $latstr = format_lat($lat);
    $string =~ s/\$LONG/$longstr/;
    $string =~ s/\$LAT/$latstr/;
    my @lines = split /\\n/, $string;

#    my ($x2, $y2) = latlon2page $zone, $long, $lat;
    my ($x2, $y2) = ($pagex, $pagey);
    #print STDERR "put_annotation: $x1 $y1 $x2 $y2\n";
# Calculate box height
    my $height = $#lines * 2 + 2;
# Calculate box width
    print TMP "gsave 0\n";
    print TMP "/Helvetica-Narrow-Latin1 1.5 selectfont\n";
    for my $line (@lines) {
	print TMP "($line) stringwidth pop 2 copy lt {exch} if pop\n";
    }
    print TMP "2 add $x2 $y2 translate 0.2 setlinewidth 0 0 0 1 setcmykcolor $x1 $y1 moveto 0 0 lineto stroke\n";
    print TMP "$x1 $y1 translate dup 2 div neg $height 2 div moveto dup 0 rlineto 0 $height neg rlineto dup neg 0 rlineto closepath gsave 0 0 0 0 setcmykcolor fill grestore 0 0 0 1 setcmykcolor stroke\n";
    print TMP "2 div neg 1 add $height 2 div 1.5 sub translate\n";
    for my $line (@lines) {
	print TMP "0 0 moveto ($line) show 0 -2 translate\n";
    }
    print TMP "grestore\n";
}

use vars qw(@ann);

sub draw_userannotations {
    my $zone = shift;
    my $xoff = shift;
    my $yoff = shift;
    my $slope = shift;
    $slope *= 3.1415926535 / 180;
    my $c = cos($slope);
    my $s = sin($slope);
    #print STDERR "cos theta: $c, sin theta: $s\n";
    #print STDERR "Draw_userannotation: $zone $xoff $yoff $slope\n";
    for my $ann (@annotations) {
	next if ${$ann}{long} < $lllongitude;
        next if ${$ann}{long} > $urlongitude;
        next if ${$ann}{lat} < $lllatitude;
        next if ${$ann}{lat} > $urlatitude;
        my ($x, $y) = latlon2page $zone, ${$ann}{long}, ${$ann}{lat};
        my ($x1, $y1) = ($x * $c + $y * $s + $xoff * (1 - $c) - $yoff * $s,
			 -$x * $s + $y * $c + $xoff * $s + $yoff * (1-$c));
	#print STDERR "($x, $y) -> ($x1, $y1)\n";
        ${$ann}{pagex} = $x1;
        ${$ann}{pagey} = $y1;
        push @ann, $ann;
    }
}

sub put_userannotations {
    for my $ann (@ann) {
	put_annotation($zone,
		       ${$ann}{pagex},
	               ${$ann}{pagey},
		       ${$ann}{long},
                       ${$ann}{lat},
                       ${$ann}{xoffset},
                       ${$ann}{yoffset},
                       ${$ann}{string}
                      );
    }
}

use vars qw($xoff $yoff);

sub drawit {
    my ($zone, $d_lllong, $d_lllat, $d_urlong, $d_urlat, $left, $right) = @_;
    my ($tlllong, $turlong, $tlllat, $turlat)
	= ($lllongitude, $urlongitude, $lllatitude, $urlatitude);
    ($lllongitude, $urlongitude, $lllatitude, $urlatitude)
	= ($d_lllong, $d_urlong, $d_lllat, $d_urlat);
    print STDERR "drawit: $zone $lllongitude $lllatitude $urlongitude $urlatitude $left $right\n";
    my $slope;

my ($lllong, $lllat, $urlong, $urlat) = ($lllongitude - 0.01,
					$lllatitude - 0.01,
					$urlongitude + 0.01,
					$urlatitude + 0.01);

    $rect = "GeometryFromText('POLYGON(($lllong $lllat, $urlong $lllat, $urlong $urlat, $lllong $urlat, $lllong $lllat))', 4283)";
    #print STDERR $rect, "\n";

# First draw everything in the margin
    
    (undef, $xoffset, $yoffset)
	= latlon_to_utm('WGS-84', $lllatitude, $lllongitude, $zone);
    
    $xoffset = -$xoffset;
    $yoffset = -$yoffset;
    
    print TMP "save 1 .1 0 .1 setcmykcolor\n";
	
    $minnorthing = min($llnorthing, $lrnorthing);
    $maxnorthing = max($ulnorthing, $urnorthing);
    $mineasting = min($lleasting, $lreasting);
    $maxeasting = max($uleasting, $ureasting);
    $startnorthing
	= (int(($minnorthing+($grid_spacing-1))/$grid_spacing)) * $grid_spacing;
    $starteasting
	= (int (($mineasting+($grid_spacing-1))/$grid_spacing)) * $grid_spacing;
    if($ongraticule) {
	if($left) { # Calculate slope and position of right hand side
	    my ($x1, $y1) = latlon2page($zone, $urlongitude, $lllatitude);
	    my ($x2, $y2) = latlon2page($zone, $urlongitude, $urlatitude);
	    $slope = atan2($y2-$y1, $x2-$x1) * 180 / 3.141596353 - 90;
	    #print STDERR
            #   "Right hand edge from ($x1, $y1) to ($x2, $y2, slope $slope\n";
	    printf TMP
		"$x1 $y1 translate %f rotate $x1 neg $y1 neg translate\n", -$slope;
	    $xoff = $x1;
	    $yoff = $y1;
	} else { # Calculate slope and position of left hand side
	    my ($x3, $y3) = latlon2page($zone, $lllongitude, $lllatitude);
	    my ($x4, $y4) = latlon2page($zone, $lllongitude, $urlatitude);
	    $slope = atan2($y4-$y3, $x4-$x3) * 180 / 3.141596353 - 90;
	    #print STDERR
	    #   "Left hand edge from ($x3, $y3) to ($x4, $y4), slope $slope\n";
	    printf TMP
		"$xoff $yoff translate %f rotate $xmin neg $ymin neg translate\n", -$slope;
	}
    }
    
    label_grid($zone, $left, $right) if defined $drawobjects{'grid'};
    label_graticule($zone, $left, $right) if defined $drawobjects{'graticule'};

# Now draw the bounding box, remembering the path which then becomes the clip path
    
    if($ongraticule) {
	my $long = $lllongitude;
	my $lat = $lllatitude;
	my ($x, $y) = latlon2page($zone, $long, $lat);
	print TMP "$x $y moveto\n";
	$long += 1/60;
	while ($long < $urlongitude) {
	    ($x, $y) = latlon2page ($zone, $long, $lat);
	    print TMP "$x $y lineto\n";
	    $long += 1/60;
	}
	$long = $urlongitude;
	($x, $y) = latlon2page ($zone, $long, $lat);
	print TMP "$x $y lineto\n";
	
	$lat += 1/60;
	while ($lat <= $urlatitude) {
	    ($x, $y) = latlon2page ($zone, $long, $lat);
	    print TMP "$x $y lineto\n";
	    $lat += 1/60;
	}
	$lat = $urlatitude;
	($x, $y) = latlon2page ($zone, $long, $lat);
	print TMP "$x $y lineto\n";
	
	$long -= 1/60;
	while ($long > $lllongitude) {
	    ($x, $y) = latlon2page ($zone, $long, $lat);
	    print TMP "$x $y lineto\n";
	    $long -= 1/60;
	}
	$long = $lllongitude;
	($x, $y) = latlon2page ($zone, $long, $lat);
	print TMP "$x $y lineto\n";
	
	$lat -= 1/60;
	while ($lat > $lllatitude) {
	    ($x, $y) = latlon2page ($zone, $long, $lat);
	    print TMP "$x $y lineto\n";
	    $lat -= 1/60;
	}
    } else { # on grid
	my($x, $y) = grid2page($lleasting, $llnorthing);
	print TMP "$x $y moveto\n";
        ($x, $y) = grid2page($lreasting, $lrnorthing);
        print TMP "$x $y lineto\n";
        ($x, $y) = grid2page($ureasting, $urnorthing);
        print TMP "$x $y lineto\n";
        ($x, $y) = grid2page($uleasting, $ulnorthing);
        print TMP "$x $y lineto\n";
    }

    print TMP "closepath\n";
    if($drawobjects{'graticule'}) {
	print TMP
	    ".1 setlinewidth 0 0 0 1 setcmykcolor gsave stroke grestore\n";
    }
    print TMP "clip newpath\n";
    
# Fetch and display all the objects
    
    for my $object_type qw(
                            hy_water_area_polygon
                            hy_water_struct_area_polygon
                            tr_air_infra_area_polygon
                          ) {
	if (defined $drawobjects{lc $object_type}) {
	    draw_areas($zone, $object_type);
	}
    }
    
    draw_lines($zone, 'Tracks', -1001)    if defined $drawobjects{'tracks'};
    draw_lines($zone, 'MineAreas')        if defined $drawobjects{'mineareas'};
    draw_lines($zone, 'Reserves', 65)     if defined $drawobjects{'reserves'};
    draw_lines($zone, 'Lakes', -114)      if defined $drawobjects{'lakes'};
    draw_lines($zone, 'hy_water_area_polygon', -114)      if defined $drawobjects{'hy_water_area_polygon'};
    draw_lines($zone, 'Reservoirs', -114) if defined $drawobjects{'reservoirs'};
    
my %line_has_width = (
                      el_contour => 0,
                      hy_water_struct_line => 0,
                      hy_watercourse => 0,
                      tr_rail => 0,
                      tr_road => 0,
                     );

    for my $object_type qw(
                  locality_polygon
                  lga_polygon
                  el_contour
                  hy_water_struct_line
                  hy_watercourse
                  tr_rail
                  tr_road
                          ) {
	if (defined $drawobjects{lc $object_type}) {
          if($object_type eq 'tr_road') {
            draw_roads($zone);
          } elsif ($object_type eq 'OSMRoads') {
            draw_osmroads($zone);
	  } elsif ($object_type eq 'lga_polygon') {
	      draw_ftype($zone, 'lga_polygon', 80);
	  } elsif ($object_type eq 'locality_polygon') {
	      draw_ftype($zone, 'locality_polygon', 650);
	  } elsif ($line_has_width{$object_type}) {
	    draw_wlines($zone, $object_type) if defined $drawobjects{lc $object_type};
	  }
	  else {
	    draw_lines($zone, $object_type) if defined $drawobjects{lc $object_type};
	  }
        }
    }
   
    for my $object_type qw(
                           hy_water_point
                           hy_water_struct_point
                           tr_airport_infrastructure
                           tr_rail_infrastructure
                           tr_road_infrastructure
                          ) {
	if (defined $drawobjects{lc $object_type}) {
	    draw_points($zone, $object_type);
	}
    }

    draw_graticule($zone) if defined $drawobjects{'graticule'};
    draw_grid($zone) if defined $drawobjects{'grid'};
#    draw_annotations($zone) if defined $drawobjects{'annotations'};

    draw_userannotations($zone, $xoff, $yoff, $slope) if defined $drawobjects{'userannotations'};

    print TMP "restore\n"; # undo the clip path
    ($lllongitude, $urlongitude, $lllatitude, $urlatitude) = ($tlllong, $turlong, $tlllat, $turlat);
}

my ($leftzone, $rightzone);

if($ongraticule) {
    ($leftzone, undef, undef)
	= latlon_to_utm('WGS-84', $lllatitude, $lllongitude+.0000001, undef);
    ($rightzone, undef, undef)
	= latlon_to_utm('WGS-84', $urlatitude, $urlongitude-.0000001, undef);
} else {
    $leftzone = $rightzone = $zone;
}

if ($leftzone eq $rightzone) {
    drawit($leftzone, $lllongitude, $lllatitude, $urlongitude, $urlatitude, 1, 1);
} else {
    my $boundary = int $urlongitude; # works for maps less than 1 degree wide
    drawit($leftzone, $lllongitude, $lllatitude, $boundary, $urlatitude, 1, 0);
    drawit($rightzone, $boundary, $lllatitude, $urlongitude, $urlatitude, 0, 1);
}

put_userannotations();

# Print out the Postscript definitions needed by this map

my %done_deps = ();

sub do_dependency {
    my $dependency = shift;

    return if defined $done_deps{$dependency};

    print STDERR "Dependency: $dependency\n";    
    my $sth = $dbh->prepare("SELECT dependencies, body FROM $symbols WHERE name = '$dependency'");
    
    $sth->execute();
    while ( my @row = $sth->fetchrow_array ) {
	my $deps = $row[0];
	my $body = $row[1];
	if ($deps) {
	    my @deps = split ' ', $deps;
	    for my $dep (@deps) {
		do_dependency($dep) unless defined $done_deps{$dep};
	    }
	}
	print $body;
	$done_deps{$dependency} = 1;
    }
}

for my $dep (keys %dependencies) {
    do_dependency($dep);
}

$dbh->disconnect();

seek TMP, 0, 0;
while(<TMP>) {
    print;
}
close TMP;

print "showpage\n";

print STDERR "$object_count objects, $point_count points\n";
